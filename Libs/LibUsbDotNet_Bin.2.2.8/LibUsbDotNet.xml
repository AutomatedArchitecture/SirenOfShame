<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LibUsbDotNet</name>
    </assembly>
    <members>
        <member name="T:LibUsbDotNet.Main.UsbRegDeviceList">
            <summary>
            Array of USB device available for communication via LibUsb or WinUsb.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.#ctor">
            <summary>
             Creates an empty <see cref="T:LibUsbDotNet.Main.UsbRegDeviceList"/> instance.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.System#Collections#Generic#IEnumerable{LibUsbDotNet#Main#UsbRegistry}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.Find(System.Predicate{LibUsbDotNet.Main.UsbRegistry})">
            <summary>
            Find the first UsbRegistry device that matches the FindUsbPredicate.  
            </summary>
            <param name="findUsbPredicate">The predicate function to use.</param>
            <returns>A valid usb registry class if the device was found or Null if the device was not found.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.FindAll(System.Predicate{LibUsbDotNet.Main.UsbRegistry})">
            <summary>
            Find all UsbRegistry devices that matches the FindUsbPredicate.  
            </summary>
            <param name="findUsbPredicate">The predicate function to use.</param>
            <returns>All usb registry classes that match.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.FindLast(System.Predicate{LibUsbDotNet.Main.UsbRegistry})">
            <summary>
            Find the last a UsbRegistry device that matches the FindUsbPredicate.  
            </summary>
            <param name="findUsbPredicate">The predicate function to use.</param>
            <returns>A valid usb registry class if the device was found or Null if the device was not found.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.Find(LibUsbDotNet.Main.UsbDeviceFinder)">
            <summary>
            Find the first UsbRegistry device using a <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance.  
            </summary>
            <param name="usbDeviceFinder">The <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance used to locate the usb registry devices.</param>
            <returns>A valid usb registry class if the device was found or Null if the device was not found.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.FindAll(LibUsbDotNet.Main.UsbDeviceFinder)">
            <summary>
            Find all UsbRegistry devices using a <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance.  
            </summary>
            <param name="usbDeviceFinder">The <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance used to locate the usb registry devices.</param>
            <returns>All usb registry classes that match.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.FindLast(LibUsbDotNet.Main.UsbDeviceFinder)">
            <summary>
            Find the last UsbRegistry devices using a <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance.  
            </summary>
            <param name="usbDeviceFinder">The <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance used to locate the usb registry devices.</param>
            <returns>A valid usb registry class if the device was found or Null if the device was not found.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.Contains(LibUsbDotNet.Main.UsbRegistry)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
            
            <returns>
            true if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"/>; otherwise, false.
            </returns>
            
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"/>.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.CopyTo(LibUsbDotNet.Main.UsbRegistry[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="offset">The zero-based index in Array at which copying begins.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">Array is null.</exception>
            <exception cref="T:System.ArgumentException">Array is multidimensional.-or-Offset is equal to or greater than the length of Array.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"/> is greater than the available space from Offset to the end of the destination Array.-or-Type T cannot be cast automatically to the type of the destination Array.</exception>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegDeviceList.IndexOf(LibUsbDotNet.Main.UsbRegistry)">
            <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1"/>.
            </summary>
            
            <returns>
            The index of item if found in the list; otherwise, -1.
            </returns>
            
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1"/>.</param>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegDeviceList.Item(System.Int32)">
            <summary>
            Gets the element at the specified index.
            </summary>
            
            <returns>
            The element at the specified index.
            </returns>
            
            <param name="index">The zero-based index of the element to get or set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the <see cref="T:System.Collections.Generic.IList`1"/>.</exception>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1"/> is read-only.</exception>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegDeviceList.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </returns>
            
        </member>
        <member name="T:LibUsbDotNet.UsbEndpointWriter">
            <summary>Contains methods for writing data to a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> or <see cref="F:LibUsbDotNet.Main.EndpointType.Interrupt"/> endpoint using the overloaded <see cref="M:LibUsbDotNet.UsbEndpointWriter.Write(System.Byte[],System.Int32,System.Int32@)"/> functions.
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.Main.UsbEndpointBase">
            <summary> 
            Endpoint members common to Read, Write, Bulk, and Interrupt <see cref="T:LibUsbDotNet.Main.EndpointType"/>.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.UsbEndpointBase.MaxReadWrite">
            <summary>
            The maximum transfer payload size for all usb endpoints.
            </summary>
            <remarks>
            Transfers greater than this amount are automatically split into
            multiple transfers.  This applies to all endpoint transfer methods
            (reads and writes). The default is 4megs (4,194,304 bytes)
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.Dispose">
            <summary>
            Frees resources associated with the endpoint.  Once disposed this <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> cannot be used.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.Abort">
            <summary>
            Aborts pending IO operation on this enpoint of one exists.
            </summary>
            <returns>True on success or if no pending IO operation exits.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.Flush">
            <summary>
            Discards any data that is cached in this endpoint.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.Reset">
            <summary>
            Resets the data toggle and clears the stall condition on an enpoint.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.Transfer(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Synchronous bulk/interrupt transfer function.
            </summary>
            <param name="buffer">An <see cref="T:System.IntPtr"/> to a caller-allocated buffer.</param>
            <param name="offset">Position in buffer that transferring begins.</param>
            <param name="length">Number of bytes, starting from thr offset parameter to transfer.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.SubmitAsyncTransfer(System.Object,System.Int32,System.Int32,System.Int32,LibUsbDotNet.Main.UsbTransfer@)">
            <summary>
            Creates, fills and submits an asynchronous <see cref="T:LibUsbDotNet.Main.UsbTransfer"/> context.
            </summary>
            <remarks>
            <note type="tip">This is a non-blocking asynchronous transfer function. This function returns immediately after the context is created and submitted.</note>
            </remarks>
            <param name="buffer">A caller-allocated buffer for the data that is transferred.</param>
            <param name="offset">Position in buffer that transferring begins.</param>
            <param name="length">Number of bytes, starting from thr offset parameter to transfer.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.</param>
            <param name="transferContext">On <see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/>, a new transfer context.</param>
            <returns><see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if the transfer context was created and <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/> succeeded.</returns>
            <seealso cref="M:LibUsbDotNet.Main.UsbEndpointBase.SubmitAsyncTransfer(System.IntPtr,System.Int32,System.Int32,System.Int32,LibUsbDotNet.Main.UsbTransfer@)"/>
            <seealso cref="M:LibUsbDotNet.Main.UsbEndpointBase.NewAsyncTransfer"/>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.SubmitAsyncTransfer(System.IntPtr,System.Int32,System.Int32,System.Int32,LibUsbDotNet.Main.UsbTransfer@)">
            <summary>
            Creates, fills and submits an asynchronous <see cref="T:LibUsbDotNet.Main.UsbTransfer"/> context.
            </summary>
            <remarks>
            <note type="tip">This is a non-blocking asynchronous transfer function. This function returns immediately after the context is created and submitted.</note>
            </remarks>
            <param name="buffer">A caller-allocated buffer for the data that is transferred.</param>
            <param name="offset">Position in buffer that transferring begins.</param>
            <param name="length">Number of bytes, starting from thr offset parameter to transfer.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.</param>
            <param name="transferContext">On <see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/>, a new transfer context.</param>
            <returns><see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if the transfer context was created and <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/> succeeded.</returns>
            <seealso cref="M:LibUsbDotNet.Main.UsbEndpointBase.SubmitAsyncTransfer(System.Object,System.Int32,System.Int32,System.Int32,LibUsbDotNet.Main.UsbTransfer@)"/>
            <seealso cref="M:LibUsbDotNet.Main.UsbEndpointBase.NewAsyncTransfer"/>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.NewAsyncTransfer">
            <summary>
            Creates a <see cref="T:LibUsbDotNet.Main.UsbTransfer"/> context for asynchronous transfers.
            </summary>
            <remarks>
            <para> This method returns a new, empty transfer context.  Unlike <see cref="M:LibUsbDotNet.Main.UsbEndpointBase.SubmitAsyncTransfer(System.Object,System.Int32,System.Int32,System.Int32,LibUsbDotNet.Main.UsbTransfer@)">SubmitAsyncTransfer</see>, this context is <c>not</c> filled and submitted.</para>
            <note type="tip">This is a non-blocking asynchronous transfer function. This function returns immediately after the context created.</note>
            </remarks>
            <returns>A new <see cref="T:LibUsbDotNet.Main.UsbTransfer"/> context.</returns>
            <seealso cref="M:LibUsbDotNet.Main.UsbEndpointBase.SubmitAsyncTransfer(System.IntPtr,System.Int32,System.Int32,System.Int32,LibUsbDotNet.Main.UsbTransfer@)"/>
            <seealso cref="M:LibUsbDotNet.Main.UsbEndpointBase.SubmitAsyncTransfer(System.Object,System.Int32,System.Int32,System.Int32,LibUsbDotNet.Main.UsbTransfer@)"/>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.LookupEndpointInfo(LibUsbDotNet.Info.UsbConfigInfo,System.Byte,LibUsbDotNet.Info.UsbInterfaceInfo@,LibUsbDotNet.Info.UsbEndpointInfo@)">
            <summary>
            Looks up endpoint/interface information in a configuration.
            </summary>
            <param name="currentConfigInfo">The config to seach.</param>
            <param name="endpointAddress">The endpoint address to look for.</param>
            <param name="usbInterfaceInfo">On success, the <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/> class for this endpoint.</param>
            <param name="usbEndpointInfo">On success, the <see cref="T:LibUsbDotNet.Info.UsbEndpointInfo"/> class for this endpoint.</param>
            <returns>True of the endpoint was found, otherwise false.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointBase.Transfer(System.Object,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Synchronous bulk/interrupt transfer function.
            </summary>
            <param name="buffer">A caller-allocated buffer for the transfer data. This object is pinned using <see cref="T:LibUsbDotNet.Main.PinnedHandle"/>.</param>
            <param name="offset">Position in buffer that transferring begins.</param>
            <param name="length">Number of bytes, starting from thr offset parameter to transfer.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>True on success.</returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbEndpointBase.IsDisposed">
            <summary>
            Gets a value indicating if the object is disposed.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbEndpointBase.Device">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.UsbDevice"/> class this endpoint belongs to.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbEndpointBase.EpNum">
            <summary>
            Gets the endpoint ID for this <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> class.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbEndpointBase.Type">
            <summary>
            Returns the <see cref="T:LibUsbDotNet.Main.EndpointType"/> for this endpoint.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbEndpointBase.EndpointInfo">
            <summary>
            Returns the <see cref="T:LibUsbDotNet.Info.UsbEndpointInfo"/> descriptor for this endpoint.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointWriter.Write(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Writes data to the current <see cref="T:LibUsbDotNet.UsbEndpointWriter"/>.
            </summary>
            <param name="buffer">The buffer storing the data to write.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointWriter.Write(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Writes data to the current <see cref="T:LibUsbDotNet.UsbEndpointWriter"/>.
            </summary>
            <param name="pBuffer">The buffer storing the data to write.</param>
            <param name="offset">The position in buffer to start writing the data from.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointWriter.Write(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Writes data to the current <see cref="T:LibUsbDotNet.UsbEndpointWriter"/>.
            </summary>
            <param name="buffer">The buffer storing the data to write.</param>
            <param name="offset">The position in buffer to start writing the data from.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointWriter.Write(System.Object,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Writes data to the current <see cref="T:LibUsbDotNet.UsbEndpointWriter"/>.
            </summary>
            <param name="buffer">The buffer storing the data to write.</param>
            <param name="offset">The position in buffer to start writing the data from.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointWriter.Write(System.Object,System.Int32,System.Int32@)">
            <summary>
            Writes data to the current <see cref="T:LibUsbDotNet.UsbEndpointWriter"/>.
            </summary>
            <param name="buffer">The buffer storing the data to write.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="T:LibUsbDotNet.UsbEndpointReader">
            <summary>
            Contains methods for retrieving data from a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> or <see cref="F:LibUsbDotNet.Main.EndpointType.Interrupt"/> endpoint using the overloaded <see cref="M:LibUsbDotNet.UsbEndpointReader.Read(System.Byte[],System.Int32,System.Int32@)"/> functions or a <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.
            </summary> 
            <remarks>
            <list type="bullet">
            <item>Before using the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event, the <see cref="P:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabled"/> property must be set to true.</item>
            <item>While the <see cref="P:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabled"/> property is True, the overloaded <see cref="M:LibUsbDotNet.UsbEndpointReader.Read(System.Byte[],System.Int32,System.Int32@)"/> functions cannot be used.</item>
            </list>
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointReader.Read(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Reads data from the current <see cref="T:LibUsbDotNet.UsbEndpointReader"/>.
            </summary>
            <param name="buffer">The buffer to store the recieved data in.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointReader.Read(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Reads data from the current <see cref="T:LibUsbDotNet.UsbEndpointReader"/>.
            </summary>
            <param name="buffer">The buffer to store the recieved data in.</param>
            <param name="offset">The position in buffer to start storing the data.</param>
            <param name="count">The maximum number of bytes to receive.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointReader.Read(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Reads data from the current <see cref="T:LibUsbDotNet.UsbEndpointReader"/>.
            </summary>
            <param name="buffer">The buffer to store the recieved data in.</param>
            <param name="offset">The position in buffer to start storing the data.</param>
            <param name="count">The maximum number of bytes to receive.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointReader.Read(System.Object,System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Reads data from the current <see cref="T:LibUsbDotNet.UsbEndpointReader"/>.
            </summary>
            <param name="buffer">The buffer to store the recieved data in.</param>
            <param name="offset">The position in buffer to start storing the data.</param>
            <param name="count">The maximum number of bytes to receive.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointReader.Read(System.Object,System.Int32,System.Int32@)">
            <summary>
            Reads data from the current <see cref="T:LibUsbDotNet.UsbEndpointReader"/>.
            </summary>
            <param name="buffer">The buffer to store the recieved data in.</param>
            <param name="timeout">Maximum time to wait for the transfer to complete.  If the transfer times out, the IO operation will be cancelled.</param>
            <param name="transferLength">Number of bytes actually transferred.</param>
            <returns>
            <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> on success.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbEndpointReader.ReadFlush">
            <summary>
            Reads/discards data from the enpoint until no more data is available.
            </summary>
            <returns>Alwats returns <see cref="F:LibUsbDotNet.Main.ErrorCode.None"/> </returns>
        </member>
        <member name="P:LibUsbDotNet.UsbEndpointReader.DefReadBufferSize">
            <summary>
            Default read buffer size when using the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.
            </summary>
            <remarks>
            This value can be bypassed using the second parameter of the <see cref="M:LibUsbDotNet.UsbDevice.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID,System.Int32)"/> method.
            The default is 4096.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabled">
            <summary>
            Gets/Sets a value indicating if the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event should be used.
            </summary>
            <remarks>
            If DataReceivedEnabled is true the <see cref="M:LibUsbDotNet.UsbEndpointReader.Read(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32@)"/> functions cannot be used.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbEndpointReader.ReadBufferSize">
            <summary>
            Size of the read buffer in bytes for the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.
            </summary>
            <remarks>
            Setting a large values, for example 64K will yield a lower number of <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> and a higher data rate. 
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbEndpointReader.ReadThreadPriority">
            <summary>
            Gets/Sets the Priority level for the read thread when <see cref="P:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabled"/> is true.
            </summary>
        </member>
        <member name="E:LibUsbDotNet.UsbEndpointReader.DataReceived">
            <summary>
            The DataReceived Event is fired when new data arrives for the current <see cref="T:LibUsbDotNet.UsbEndpointReader"/>.
            </summary>
            <remarks>To use the DataReceived event, <see cref="P:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabled"/> must be set to truw.</remarks>
        </member>
        <member name="E:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabledChanged">
            <summary>
            The <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabledChanged"/> Event is fired when the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event is started or stopped.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.WinUsb.DeviceInformationTypes">
            <summary> Types of information that can be retrieved with the WinUsb QueryDevice function.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.WinUsb.DeviceInformationTypes.DeviceSpeed">
            <summary>
            The device speed.
            </summary>
        </member>
        <member name="T:MonoLibUsb.MonoUsbDeviceHandle">
            <summary>
            Represents a Libusb-1.0 device handle.
            </summary>
            <remarks>
            <para>To close a device, see the <see cref="M:MonoLibUsb.MonoUsbDeviceHandle.Close"/> method.</para>
            <note title="Libusb-1.0 API Note:" type="cpp">A <see cref="T:MonoLibUsb.MonoUsbDeviceHandle"/> is roughly equivalent to a <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html#ga7df95821d20d27b5597f1d783749d6a4">libusb_device_handle</a>.</note>
            </remarks>
            <code>
            MonoUsbDeviceHandle deviceHandle = new MonoUsbDeviceHandle(profileHandle);
            if (deviceHandle.IsInvalid) throw new Exception("Invalid device context.");
            </code>
        </member>
        <member name="T:LibUsbDotNet.Main.SafeContextHandle">
            <summary>
            Base class for all critial handles.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.SafeContextHandle.#ctor(System.IntPtr,System.Boolean)">
            <summary>
            
            </summary>
            <param name="pHandle"></param>
            <param name="ownsHandle"></param>
        </member>
        <member name="M:LibUsbDotNet.Main.SafeContextHandle.#ctor(System.IntPtr)">
            <summary>
            
            </summary>
            <param name="pHandleToOwn"></param>
        </member>
        <member name="P:LibUsbDotNet.Main.SafeContextHandle.IsInvalid">
            <summary>
            Gets a value indicating whether the handle value is invalid.
            </summary>
            <returns>
            true if the handle value is invalid; otherwise, false.
            </returns>
            <PermissionSet><IPermission class="System.Security.Permissions.SecurityPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" Flags="UnmanagedCode"/></PermissionSet>
        </member>
        <member name="M:MonoLibUsb.MonoUsbDeviceHandle.#ctor(MonoLibUsb.Profile.MonoUsbProfileHandle)">
            <summary>Open a device handle from <paramref name="profileHandle"/>.</summary>
            <remarks>
            <para>A handle allows you to perform I/O on the device in question.</para>
            <para>To close a device handle call its <see cref="M:System.Runtime.InteropServices.SafeHandle.Close"/> method.</para>
            <para>This is a non-blocking function; no requests are sent over the bus.</para>
            <note title="Libusb-1.0 API Note:" type="cpp">The <see cref="M:MonoLibUsb.MonoUsbDeviceHandle.#ctor(MonoLibUsb.Profile.MonoUsbProfileHandle)"/> constructor is roughly equivalent to <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html#ga8163100afdf933fabed0db7fa81c89d1">libusb_open()</a>.</note>
            </remarks>
            <param name="profileHandle">A device profile handle.</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbDeviceHandle.ReleaseHandle">
            <summary>
            Closes the <see cref="T:MonoLibUsb.MonoUsbDeviceHandle"/>.
            </summary>
            <returns>
            true if the <see cref="T:MonoLibUsb.MonoUsbDeviceHandle"/> is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a ReleaseHandleFailed Managed Debugging Assistant.
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbDeviceHandle.Close">
            <summary>
            Closes the <see cref="T:MonoLibUsb.MonoUsbDeviceHandle"/> reference.  When all references are no longer is use, the device
            is closed in the <see cref="M:MonoLibUsb.MonoUsbDeviceHandle.ReleaseHandle"/> finalizer.
            </summary>
            <remarks>
            <note title="Libusb-1.0 API Note:" type="cpp">The <see cref="M:MonoLibUsb.MonoUsbDeviceHandle.Close"/> method is roughly equivalent to <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html#ga779bc4f1316bdb0ac383bddbd538620e">libusb_close()</a>.</note>
            </remarks>
        </member>
        <member name="P:MonoLibUsb.MonoUsbDeviceHandle.LastErrorString">
            <summary>
            If the device handle is <see cref="P:LibUsbDotNet.Main.SafeContextHandle.IsInvalid"/>, gets a descriptive string for the <see cref="P:MonoLibUsb.MonoUsbDeviceHandle.LastErrorCode"/>.
            </summary>
        </member>
        <member name="P:MonoLibUsb.MonoUsbDeviceHandle.LastErrorCode">
            <summary>
            If the device handle is <see cref="P:LibUsbDotNet.Main.SafeContextHandle.IsInvalid"/>, gets the <see cref="T:MonoLibUsb.MonoUsbError"/> status code indicating the reason.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbTransfer">
            <summary>
            Base class for async transfer context.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mIsoPacketSize">
            <summary></summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mOriginalCount">
            <summary></summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mOriginalOffset">
            <summary></summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mTimeout">
            <summary></summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mHasWaitBeenCalled">
            <summary></summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mTransferLOCK">
            <summary></summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mTransferCancelEvent">
            <summary></summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransfer.mTransferCompleteEvent">
            <summary></summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.#ctor(LibUsbDotNet.Main.UsbEndpointBase)">
            <summary></summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Dispose">
            <summary>
            Cancels any pending transfer and frees resources.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Cancel">
            <summary>
            Cancels a pending transfer that was previously submitted with <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Submit">
            <summary>
            Submits the transfer.
            </summary>
            <remarks>
            This functions submits the USB transfer and return immediately.
            </remarks>
            <returns>
            <see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if the submit succeeds, 
            otherwise one of the other <see cref="T:LibUsbDotNet.Main.ErrorCode"/> codes.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Wait(System.Int32@,System.Boolean)">
            <summary>
            Wait for the transfer to complete, timeout, or get cancelled.
            </summary>
            <param name="transferredCount">The number of bytes transferred on <see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/>.</param>
            <param name="cancel">If true, the transfer is cancelled if it does not complete within the time specified in <see cref="T:System.Threading.Timeout"/>.</param>
            <returns><see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if the transfer completes successfully, otherwise one of the other <see cref="T:LibUsbDotNet.Main.ErrorCode"/> codes.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Wait(System.Int32@)">
            <summary>
            Wait for the transfer to complete, timeout, or get cancelled.
            </summary>
            <param name="transferredCount">The number of bytes transferred on <see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/>.</param>
            <returns><see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if the transfer completes successfully, otherwise one of the other <see cref="T:LibUsbDotNet.Main.ErrorCode"/> codes.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Fill(System.Object,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills the transfer with the data to <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/>.
            </summary>
            <param name="buffer">The buffer; See <see cref="T:LibUsbDotNet.Main.PinnedHandle"/> for more details.</param>
            <param name="offset">The offset on the buffer where the transfer should read/write.</param>
            <param name="count">The number of bytes to transfer.</param>
            <param name="timeout">Time (milliseconds) to wait before the transfer times out.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Fill(System.Object,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills the transfer with the data to <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/> an isochronous transfer.
            </summary>
            <param name="buffer">The buffer; See <see cref="T:LibUsbDotNet.Main.PinnedHandle"/> for more details.</param>
            <param name="offset">The offset on the buffer where the transfer should read/write.</param>
            <param name="count">The number of bytes to transfer.</param>
            <param name="timeout">Time (milliseconds) to wait before the transfer times out.</param>
            <param name="isoPacketSize">Size of each isochronous packet.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Fill(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills the transfer with the data to <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/>.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset on the buffer where the transfer should read/write.</param>
            <param name="count">The number of bytes to transfer.</param>
            <param name="timeout">Time (milliseconds) to wait before the transfer times out.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Fill(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills the transfer with the data to <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/> an isochronous transfer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset on the buffer where the transfer should read/write.</param>
            <param name="count">The number of bytes to transfer.</param>
            <param name="timeout">Time (milliseconds) to wait before the transfer times out.</param>
            <param name="isoPacketSize">Size of each isochronous packet.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.IncrementTransfer(System.Int32)">
            <summary>
            Increments the internal counters to the next transfer batch (for transfers greater than <see cref="F:LibUsbDotNet.Main.UsbEndpointBase.MaxReadWrite"/>)
            </summary>
            <param name="amount">This will usually be the total transferred on the previous batch.</param>
            <returns>True if the buffer still has data available and internal counters were successfully incremented.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransfer.Reset">
            <summary>
            Resets the transfer to its orignal state.
            </summary>
            <remarks>
            Prepares a <see cref="T:LibUsbDotNet.Main.UsbTransfer"/> to be resubmitted.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.EndpointBase">
            <summary>
            Returns the <see cref="T:LibUsbDotNet.UsbEndpointReader"/> or <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> this transfer context is associated with.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.RequestCount">
            <summary>
            Number of bytes that will be requested for the next transfer.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.NextBufPtr">
            <summary></summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.IsCancelled">
            <summary>
             True if the transfer has been cacelled with <see cref="M:LibUsbDotNet.Main.UsbTransfer.Cancel"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.CancelWaitHandle">
            <summary>
            Gets the <see cref="T:System.Threading.WaitHandle"/> for the cancel event.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.IsoPacketSize">
            <summary>
            Gets the size of each isochronous packet.
            </summary>
            <remarks>
            To change the packet size see <see cref="M:LibUsbDotNet.Main.UsbTransfer.Fill(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)"/>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.Transmitted">
            <summary>
            Totoal number of bytes transferred.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.Remaining">
            <summary>
            Remaining bytes in the transfer data buffer.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.IsCompleted">
            <summary>
            Gets an indication whether the asynchronous operation has completed.
            </summary>
            <returns>
            true if the operation is complete; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.AsyncWaitHandle">
            <summary>
            Gets a <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.
            </summary>
            <returns>
            A <see cref="T:System.Threading.WaitHandle"/> that is used to wait for an asynchronous operation to complete.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.AsyncState">
            <summary>
            Gets a user-defined object that qualifies or contains information about an asynchronous operation.
            </summary>
            <returns>
            A user-defined object that qualifies or contains information about an asynchronous operation.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransfer.CompletedSynchronously">
            <summary>
            Gets an indication of whether the asynchronous operation completed synchronously.
            </summary>
            <returns>
            true if the asynchronous operation completed synchronously; otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_control_setup.bmRequestType">
            Request type. Bits 0:4 determine recipient, see
            \ref libusb_request_recipient. Bits 5:6 determine type, see
            \ref libusb_request_type. Bit 7 determines data transfer direction, see
            \ref libusb_endpoint_direction.
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_control_setup.bRequest">
            Request. If the type bits of bmRequestType are equal to
            \ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD
            "LIBUSB_REQUEST_TYPE_STANDARD" then this field refers to
            \ref libusb_standard_request. For other cases, use of this field is
            application-specific. 
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_control_setup.wValue">
            Value. Varies according to request 
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_control_setup.wIndex">
            Index. Varies according to request, typically used to pass an index
            or offset 
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_control_setup.wLength">
            Number of bytes to transfer 
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo">
            <summary> Describes the storage volume that caused the notification.
            See <see cref="T:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo"/> for more information.
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo">
            <summary> Common interface describing a storage volume arrival or removal notification.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo.Letter">
            <summary>
            Under windows, gets the letter representation of the unitmask.
            Under linux, gets the full path of the device name.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo.ChangeAffectsMediaInDrive">
            <summary>
             If true, change affects media in drive. If false, change affects physical device or drive.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo.IsNetworkVolume">
            <summary>
            If True, the indicated logical volume is a network volume
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo.Flags">
            <summary>
            Raw DevBroadcastVolume flags.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IVolumeNotifyInfo.Unitmask">
            <summary>
            Gets the bit unit mask of the device. IE (bit 0 = A:, bit 1 = B:, etc..)
            </summary>
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo.Letter">
            <summary>
            Gets the letter representation of the unitmask.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo.ChangeAffectsMediaInDrive">
            <summary>
             If true, change affects media in drive. If false, change affects physical device or drive.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo.IsNetworkVolume">
            <summary>
            If True, the indicated logical volume is a network volume
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo.Flags">
            <summary>
            Raw DevBroadcastVolume flags.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo.Unitmask">
            <summary>
            Gets the bit unit mask of the device. IE (bit 0 = A:, bit 1 = B:, etc..)
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.DeviceType">
            <summary> 
            Type of notification device.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.DeviceType.Oem">
            <summary>
            oem-defined device type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.DeviceType.DevNode">
            <summary>
            devnode number.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.DeviceType.Volume">
            <summary>
            logical volume.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.DeviceType.Port">
            <summary>
            serial, parallel.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.DeviceType.Net">
            <summary>
            network resource.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.DeviceType.DeviceInterface">
            <summary>
            device interface class
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.DeviceType.Handle">
            <summary>
            file system handle.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Descriptors.UsbEndpointDescriptor">
            <summary> Usb Endpoint Descriptor
            </summary> 
            <remarks> This is the actual descriptor as described in the USB 2.0 Specifications.
            </remarks> 
        </member>
        <member name="T:LibUsbDotNet.Descriptors.UsbDescriptor">
            <summary> Base class for all usb descriptors structures.
            </summary> 
            <remarks> This is the actual descriptor as described in the USB 2.0 Specifications.
            </remarks> 
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDescriptor.ToStringParamValueSeperator">
            <summary>
            String value used to seperate the name/value pairs for all ToString overloads of the descriptor classes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDescriptor.ToStringFieldSeperator">
            <summary>
            String value used to seperate the name/value groups for all ToString overloads of the descriptor classes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDescriptor.Size">
            <summary>
            Total size of this structure in bytes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDescriptor.Length">
            <summary>
            Length of structure reported by the associated usb device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDescriptor.DescriptorType">
            <summary>
            Type of structure reported by the associated usb device.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDescriptor.ToString">
            <summary>
            String representation of the UsbDescriptor class.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.Size">
            <summary>
            Total size of this structure in bytes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.EndpointID">
            <summary>
            Endpoint Address
            Bits 0..3b Endpoint Number.
            Bits 4..6b Reserved. Set to Zero
            Bits 7 Direction 0 = Out, 1 = In (Ignored for Control Endpoints)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.Attributes">
            <summary>
            Bits 0..1 Transfer Type 
            00 = Control
            01 = Isochronous
            10 = Bulk
            11 = Interrupt
            
            Bits 2..7 are reserved. If Isochronous endpoint, 
            Bits 3..2 = Synchronisation Type (Iso Mode) 
            00 = No Synchonisation
            01 = Asynchronous
            10 = Adaptive
            11 = Synchronous
            
            Bits 5..4 = Usage Type (Iso Mode) 
            00 = Data Endpoint
            01 = Feedback Endpoint
            10 = Explicit Feedback Data Endpoint
            11 = Reserved
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.MaxPacketSize">
            <summary>
            Maximum Packet Size this endpoint is capable of sending or receiving
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.Interval">
            <summary>
            Interval for polling endpoint data transfers. Value in frame counts. Ignored for Bulk and Control Endpoints. Isochronous must equal 1 and field may range from 1 to 255 for interrupt endpoints.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.Refresh">
            <summary>
            Audio endpoint specific.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.SynchAddress">
            <summary>
            Audio endpoint specific.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbEndpointDescriptor"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbEndpointDescriptor"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbEndpointDescriptor.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbEndpointDescriptor"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Descriptors.UsbEndpointDescriptor"/>.</returns>
        </member>
        <member name="T:LibUsbDotNet.WinUsb.PipePolicies">
            <summary> Endpoint specific policies. <see cref="M:LibUsbDotNet.WinUsb.WinUsbDevice.EndpointPolicies(LibUsbDotNet.Main.ReadEndpointID)"/>.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.WinUsb.PipePolicies.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.PipePolicies.Finalize">
            <summary>
            Frees instance resources.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.AllowPartialReads">
            <summary>
            If the allow partial reads policy parameter is FALSE (that is, zero), the read request fails whenever the device returns more data than the client requested. 
            If the allow partial reads policy parameter is TRUE, the WinUSB driver saves the extra data and sends the extra data to the client during the client's next read. 
            The default value of the allow partial reads policy parameter is TRUE.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.ShortPacketTerminate">
            <summary>
            If the short packet terminate policy parameter is TRUE (that is, nonzero), every write request that is a multiple of the maximum packet size for the endpoint is terminated with a zero-length packet. 
            The default value of the short packet terminate policy parameter is FALSE.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.AutoClearStall">
            <summary>
            If the auto clear stall policy parameter is TRUE (that is, nonzero), the driver fails stalled data transfers, but the driver clears the stall condition automatically, and data continues to flow on the pipe. This policy parameter does not affect control pipes. 
            The default value for the auto clear stall policy parameter is FALSE.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.AutoFlush">
            <summary>
             The auto flush policy parameter works with allow partial reads. If allow partial reads is FALSE, the WinUSB driver ignores the value of auto flush. If allow partial reads is TRUE, the value of auto flush determines what the WinUSB driver does when the device returns more data than the client requested. 
             If both allow partial reads and auto flush policy parameters are TRUE (that is, nonzero) and the device returns more data than the client requested, the remaining data is discarded. If allow partial reads is TRUE, but auto flush is FALSE, the WinUSB driver caches the extra data and sends it to the client in the next read operation. 
             The default value of the auto flush policy parameter is FALSE.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.IgnoreShortPackets">
            <summary>
            If the ignore short packets policy parameter is TRUE (that is, nonzero), the host does not complete a read operation after it receives a short packet. Instead, the the host completes the operation only after the host has read the specified number of bytes. 
            If the ignore short packets policy parameter is FALSE, the host completes a read operation when either the host has read the specified number of bytes or the host has received a short packet. 
            The default value of the ignore short packets policy parameter is FALSE.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.RawIo">
            <summary>
            If the raw i/o policy parameter is TRUE (that is, nonzero), calls to WinUsb_ReadPipe and WinUsb_WritePipe for the specified endpoint must satisfy the following conditions:
            The buffer length must be a multiple of the maximum endpoint packet size. 
            The length must be less than what the host controller supports. 
            If the preceding conditions are met, WinUSB sends data directly to the USB driver stack, bypassing WinUSB's queuing and error handling. 
            If the raw i/o policy parameter is FALSE, no restrictions are imposed on the buffers that are passed to WinUsb_ReadPipe and WinUsb_WritePipe. 
            The default value of the raw i/o policy parameter is FALSE.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.PipeTransferTimeout">
            <summary>
            The pipe transfer timeout policy parameter specifies the time-out interval, in milliseconds. The host cancels transfers that do not complete within the time-out interval. A value of zero means that transfers do not time out. 
            By default, the time-out value is zero, and the host never cancels a transfer because of a time-out.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PipePolicies.MaxTransferSize">
            <summary>
            The maximum number of bytes that can be transferred at once.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Descriptors.MonoUsbInterface">
            <summary>A collection of alternate settings for a particular USB interface.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbInterface.pAltSetting">
            <summary> Array of interface descriptors. The length of this array is determined by the num_altsetting field.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbInterface.num_altsetting">
            <summary> The number of alternate settings that belong to this interface</summary>
        </member>
        <member name="P:MonoLibUsb.Descriptors.MonoUsbInterface.AltInterfaceList">
            <summary> Array of interface descriptors. The length of this array is determined by the num_altsetting field.</summary>
        </member>
        <member name="T:MonoLibUsb.Profile.AddRemoveType">
            <summary>
            Event type.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Profile.AddRemoveType.Added">
            <summary>
            A usb device was attached.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Profile.AddRemoveType.Removed">
            <summary>
            A usb device was detached.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier">
            <summary>
             Creates an instance of the <see cref="T:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier"/> class.
             See the <see cref="T:LibUsbDotNet.DeviceNotify.IDeviceNotifier"/> interface or <see cref="M:LibUsbDotNet.DeviceNotify.DeviceNotifier.OpenDeviceNotifier"/> method for more information
            </summary>
            <remarks>
            To make your code platform-independent use the <see cref="M:LibUsbDotNet.DeviceNotify.DeviceNotifier.OpenDeviceNotifier"/> method for creating instances.
            </remarks>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.IDeviceNotifier">
            <summary>
            Notifies an application of a change to the hardware Configuration of a device or 
            the computer.
            </summary>
            <remarks>
            For devices that offer software-controllable features, such as ejection and locking, 
            the system typically sends a <see cref="F:LibUsbDotNet.DeviceNotify.EventType.DeviceRemovePending"/> message to 
            let applications and device drivers end their use of the device gracefully. If the 
            system forcibly removes a device, it may not send a 
            <see cref="F:LibUsbDotNet.DeviceNotify.EventType.DeviceQueryRemove"/> message before doing so.
            </remarks>
            <example>
            <code source="..\Test_DeviceNotify\fTestDeviceNotify.cs" lang="cs"/>
            </example>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.IDeviceNotifier.Enabled">
            <summary>
             Enables/Disables notification events.
            </summary>
        </member>
        <member name="E:LibUsbDotNet.DeviceNotify.IDeviceNotifier.OnDeviceNotify">
            <summary>
            Main Notify event for all device notifications.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier.#ctor(System.String)">
            <summary>
            Creates a new instance of the LinuxDeviceNotifier using 'devDir' as the root device path. (IE. '/dev').
            </summary>
            <param name="devDir">The directory to monitor; usually '/dev'.</param>
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier.#ctor">
            <summary>
            Creates a new instance of the LinuxDeviceNotifier using '/dev' as the root device path.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier.PollingInterval">
            <summary>
             The interval (milliseconds) in which the device list is queried for changes when using the <see cref="F:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifierMode.PollDeviceList"/> mode.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier.Mode">
            <summary>
             Gets the mode being used to detect notification events.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier.Enabled">
            <summary>
             Enables/Disables notification events.
            </summary>
        </member>
        <member name="E:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier.OnDeviceNotify">
            <summary>
            Main Notify event for all device notifications.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Profile.MonoUsbProfileList">
            <summary>
            Manages the device list.  This class is thread safe.
            </summary>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileList.Refresh(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Refreshes the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> list.
            </summary>
            <remarks>
            <para>This is your entry point into finding a USB device to operate.</para>
            <para>This return value of this function indicates the number of devices in the resultant list.</para>
            <para>The <see cref="T:MonoLibUsb.Profile.MonoUsbProfileList"/> has a crude form of built-in device notification that works on all platforms. By adding an event handler to the <see cref="E:MonoLibUsb.Profile.MonoUsbProfileList.AddRemoveEvent"/> changes in the device profile list are reported when <see cref="M:MonoLibUsb.Profile.MonoUsbProfileList.Refresh(MonoLibUsb.MonoUsbSessionHandle)"/> is called.</para>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <returns>The number of devices in the outputted list, or <see cref="F:MonoLibUsb.MonoUsbError.ErrorNoMem"/> on memory allocation failure.</returns>
            <example>
            <code source="..\MonoLibUsb\MonoUsb.ShowInfo\ShowInfo.cs" lang="cs"/>
            </example>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileList.Close">
            <summary>
            Frees all unreferenced profiles contained in the list.
            </summary>
            <remarks>
            <para>
            <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/>s that are in-use are never closed until all reference(s) have gone 
            out-of-scope or specifically been closed with the <see cref="M:System.Runtime.InteropServices.SafeHandle.Close"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileList.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileList.GetList">
            <summary>
            Gets a <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> instances.
            </summary>
            <remarks>
            <para>
            The <see cref="T:MonoLibUsb.Profile.MonoUsbProfileList"/> uses an internal list that is locked when changes must be made.
            The <see cref="M:MonoLibUsb.Profile.MonoUsbProfileList.GetList"/> method returns a copy of this list that can be searched and modified as needed by the user.
            </para>
            <para>
            The returned generic <see cref="T:System.Collections.Generic.List`1"/> contains many more functions for finding devices.  
            It may be desirable to use these members, such as <see cref="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})"/> or <see cref="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})"/> to find a <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> instead of iterating through the <see cref="T:MonoLibUsb.Profile.MonoUsbProfileList"/> one-by-one.
            </para>
            </remarks>
            <returns>A <see cref="T:System.Collections.Generic.List`1"/> of <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> instances.</returns>
        </member>
        <member name="E:MonoLibUsb.Profile.MonoUsbProfileList.AddRemoveEvent">
            <summary>
            Usb device arrival/removal notification handler. 
            This event only reports when the <see cref="M:MonoLibUsb.Profile.MonoUsbProfileList.Refresh(MonoLibUsb.MonoUsbSessionHandle)"/> method is called.
            </summary>
            <remarks>
            <see cref="E:MonoLibUsb.Profile.MonoUsbProfileList.AddRemoveEvent"/> could be used for a crude form for receiving usb 
            device arrival/removal notification.
            </remarks>
            <example>
            <code>
            // Startup code
            MonoUsbProfileList profileList = new MonoUsbProfileList();
            profileList.AddRemoveEvent += OnDeviceAddRemove;
            
            // Device AddRemove event template
            private void OnDeviceAddRemove(object sender, AddRemoveEventArgs addRemoveArgs)
            {
            // This method will only report when Refresh() is called.
            }
            
            // Refresh profile list.
            // Any devices added or removed since the last call to Refresh() will be returned
            // in the OnDeviceAddRemove method.
            profileList.Refresh();
            </code>
            </example>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfileList.Count">
            <summary>
            Returns the number of <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> instances in the list.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfileList.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> at the specfied index.
            </summary>
            <param name="index">The index of the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> to retrieve.</param>
            <returns>The <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> instance at the specified <paramref name="index"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is invalid.</exception>
        </member>
        <member name="T:MonoLibUsb.Profile.MonoUsbProfile">
            <summary>
            Representing a USB device that can be opened and used by Libusb-1.0.
            </summary>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfile.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfile.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfile.op_Equality(MonoLibUsb.Profile.MonoUsbProfile,MonoLibUsb.Profile.MonoUsbProfile)">
            <summary>
             <c>true</c> if the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> types are equal.
            </summary>
             <remarks>
             <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> types are considered equal they have the same <see cref="P:MonoLibUsb.Profile.MonoUsbProfile.BusNumber"/> and <see cref="P:MonoLibUsb.Profile.MonoUsbProfile.DeviceAddress"/>.
             </remarks>
            <param name="left"><see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> on the left.</param>
            <param name="right"><see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> on the right.</param>
            <returns>True if the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> types are equal.</returns>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfile.op_Inequality(MonoLibUsb.Profile.MonoUsbProfile,MonoLibUsb.Profile.MonoUsbProfile)">
            <summary>
             <c>true</c> if the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> types are not equal.
            </summary>
             <remarks>
             <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> types are considered equal they have the same <see cref="P:MonoLibUsb.Profile.MonoUsbProfile.BusNumber"/> and <see cref="P:MonoLibUsb.Profile.MonoUsbProfile.DeviceAddress"/>.
             </remarks>
            <param name="left"><see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> on the left.</param>
            <param name="right"><see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> on the right.</param>
            <returns>True if the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> types are not equal.</returns>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfile.Close">
            <summary>
            Closes the internal <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/>.
            </summary>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfile.OpenDeviceHandle">
            <summary>
            Convenience function to open the device handle this profile handle represents.
            </summary>
            <returns>
            A new <see cref="T:MonoLibUsb.MonoUsbDeviceHandle"/> instance. Created with <see cref="M:MonoLibUsb.MonoUsbDeviceHandle.#ctor(MonoLibUsb.Profile.MonoUsbProfileHandle)"/> constructor.
            </returns>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfile.Equals(MonoLibUsb.Profile.MonoUsbProfile)">
            <summary>
            Compares a <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> with this one.
            </summary>
            <param name="other">The other <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/>.</param>
            <returns>True if the <see cref="P:MonoLibUsb.Profile.MonoUsbProfile.BusNumber"/> and <see cref="P:MonoLibUsb.Profile.MonoUsbProfile.DeviceAddress"/> are equal.</returns>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfile.DeviceDescriptor">
            <summary>
            Gets the standard usb device descriptor.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfile.BusNumber">
            <summary>
            Gets the bus number the is resides on.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfile.DeviceAddress">
            <summary>
            Gets the device address that belongs to the usb device this profile represents.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfile.ProfileHandle">
            <summary>
            Gets the internal profile handle need for some api calls.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.LibUsb.LibUsbDevice">
            <summary> Contains members that are specific to the LibUsb-Win32 driver.
            </summary> 
            <remarks> Use the <see cref="T:LibUsbDotNet.UsbDevice"/> class instead to allow your code to work with either LibUsb or WinUsb.
            </remarks> 
        </member>
        <member name="T:LibUsbDotNet.UsbDevice">
            <summary>Contains non-driver specific USB device communication members.</summary>
            <remarks>
            This class is compatible with WinUSB, LibUsb-Win32, and linux libusb v1.x. 
            Platform independent applications should only use usb device members from this class.
            If more functionality is required, it is up to the application to handle multi-driver
            and/or multi-platfrom requirements.
            </remarks>
        </member>
        <member name="F:LibUsbDotNet.UsbDevice.ForceLegacyLibUsb">
            <summary>
            
            </summary>
        </member>
        <member name="F:LibUsbDotNet.UsbDevice.ForceLibUsbWinBack">
            <summary>
            Setting this field to <see langword="true"/> will force <see cref="N:LibUsbDotNet"/> to use the <a href="http://www.libusb.org/wiki/windows_backend">Libusb-1.0 Windows-backend driver.</a>  For platforms other than windows, this setting has no effect.
            </summary>
            <remarks>
            If this is <see langword="true"/>, <see cref="P:LibUsbDotNet.UsbDevice.AllDevices"/> will return only <see cref="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice"/>s in the list.
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.Close">
            <summary>
            Closes the <see cref="T:LibUsbDotNet.UsbDevice"/> and disposes any <see cref="P:LibUsbDotNet.UsbDevice.ActiveEndpoints"/>.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.Open">
            <summary>
             Opens the USB device handle.
            </summary>
            <returns>
            True if the device is already opened or was opened successfully.
            False if the device does not exists or is no longer valid.  
            </returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.ControlTransfer(LibUsbDotNet.Main.UsbSetupPacket@,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Transmits control data over a default control endpoint.
            </summary>
            <param name="setupPacket">An 8-byte setup packet which contains parameters for the control request. 
            See section 9.3 USB Device Requests of the Universal Serial Bus Specification Revision 2.0 for more information. </param>
            <param name="buffer">Data to be sent/received from the device.</param>
            <param name="bufferLength">Length of the buffer param.</param>
            <param name="lengthTransferred">Number of bytes sent or received (depends on the direction of the control transfer).</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.ControlTransfer(LibUsbDotNet.Main.UsbSetupPacket@,System.Object,System.Int32,System.Int32@)">
            <summary>
            Transmits control data over a default control endpoint.
            </summary>
            <param name="setupPacket">An 8-byte setup packet which contains parameters for the control request. 
            See section 9.3 USB Device Requests of the Universal Serial Bus Specification Revision 2.0 for more information. </param>
            <param name="buffer">Data to be sent/received from the device.</param>
            <param name="bufferLength">Length of the buffer param.</param>
            <param name="lengthTransferred">Number of bytes sent or received (depends on the direction of the control transfer).</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.GetConfiguration(System.Byte@)">
            <summary>
            Gets the USB devices active configuration value. 
            </summary>
            <param name="config">The active configuration value. A zero value means the device is not configured and a non-zero value indicates the device is configured.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.GetDescriptor(System.Byte,System.Byte,System.Int16,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Gets a descriptor from the device. See <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> for more information.
            </summary>
            <param name="descriptorType">The descriptor type ID to retrieve; this is usually one of the <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> enumerations.</param>
            <param name="index">Descriptor index.</param>
            <param name="langId">Descriptor language id.</param>
            <param name="buffer">Memory to store the returned descriptor in.</param>
            <param name="bufferLength">Length of the buffer parameter in bytes.</param>
            <param name="transferLength">The number of bytes transferred to buffer upon success.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenEndpointWriter(LibUsbDotNet.Main.WriteEndpointID)">
            <summary>
            Opens a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> endpoint for writing
            </summary>
            <param name="writeEndpointID">Endpoint number for read operations.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class ready for writing. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenEndpointWriter(LibUsbDotNet.Main.WriteEndpointID,LibUsbDotNet.Main.EndpointType)">
            <summary>
            Opens an endpoint for writing
            </summary>
            <param name="writeEndpointID">Endpoint number for read operations.</param>
            <param name="endpointType">The type of endpoint to open.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class ready for writing. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.GetDescriptor(System.Byte,System.Byte,System.Int16,System.Object,System.Int32,System.Int32@)">
            <summary>
            Gets a descriptor from the device. See <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> for more information.
            </summary>
            <param name="descriptorType">The descriptor type ID to retrieve; this is usually one of the <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> enumerations.</param>
            <param name="index">Descriptor index.</param>
            <param name="langId">Descriptor language id.</param>
            <param name="buffer">Memory to store the returned descriptor in.</param>
            <param name="bufferLength">Length of the buffer parameter in bytes.</param>
            <param name="transferLength">The number of bytes transferred to buffer upon success.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.GetLangIDs(System.Int16[]@)">
            <summary>
            Asking for the zero'th index is special - it returns a string
            descriptor that contains all the language IDs supported by the
            device. Typically there aren't many - often only one. The
            language IDs are 16 bit numbers, and they start at the third byte
            in the descriptor. See USB 2.0 specification, section 9.6.7, for
            more information on this. 
            </summary>
            <returns>A collection of LCIDs that the current <see cref="T:LibUsbDotNet.UsbDevice"/> supports.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.GetString(System.String@,System.Int16,System.Byte)">
            <summary>
            Gets a <see cref="F:LibUsbDotNet.Descriptors.DescriptorType.String"/> descriptor from the device.
            </summary>
            <param name="stringData">Buffer to store the returned string in upon success.</param>
            <param name="langId">The language ID to retrieve the string in. (0x409 for english).</param>
            <param name="stringIndex">The string index to retrieve.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID)">
            <summary>
            Opens a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> endpoint for reading
            </summary>
            <param name="readEndpointID">Endpoint number for read operations.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class ready for reading. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID,System.Int32)">
            <summary>
            Opens a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> endpoint for reading
            </summary>
            <param name="readEndpointID">Endpoint number for read operations.</param>
            <param name="readBufferSize">Size of the read buffer allocated for the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class ready for reading. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID,System.Int32,LibUsbDotNet.Main.EndpointType)">
            <summary>
            Opens an endpoint for reading
            </summary>
            <param name="readEndpointID">Endpoint number for read operations.</param>
            <param name="readBufferSize">Size of the read buffer allocated for the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.</param>
            <param name="endpointType">The type of endpoint to open.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class ready for reading. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.GetAltInterfaceSetting(System.Byte,System.Byte@)">
            <summary>
            Gets the selected alternate interface of the specified interface.
            </summary>
            <param name="interfaceID">The interface settings number (index) to retrieve the selected alternate interface setting for.</param>
            <param name="selectedAltInterfaceID">The alternate interface setting selected for use with the specified interface.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.Exit">
            <summary>
            De-initializes the USB driver. 
            </summary>
            <remarks>
            If this method is not called before the application exits, it can cause it to hang indefinitely.
            <para>Calling this method multiple times will have no effect.</para>
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenUsbDevice(LibUsbDotNet.Main.UsbDeviceFinder)">
            <summary>
            Opens the usb device that matches the <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/>.
            </summary>
            <param name="usbDeviceFinder">The <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> class used to find the usb device.</param>
            <returns>An valid/open usb device class if the device was found or Null if the device was not found.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenUsbDevice(System.Predicate{LibUsbDotNet.Main.UsbRegistry})">
            <summary>
            Opens the usb device that matches the find predicate.
            </summary>
            <param name="findDevicePredicate">The predicate function used to find the usb device.</param>
            <returns>An valid/open usb device class if the device was found or Null if the device was not found.</returns>
        </member>
        <member name="M:LibUsbDotNet.UsbDevice.OpenUsbDevice(System.Guid@,LibUsbDotNet.UsbDevice@)">
            <summary>
            Opens a WinUsb device by its DeviceInterfaceGUID.
            </summary>
            <remarks>
            This is the Microsoft-recommended way for opening a WinUsb device.  
            LibUsb device can be opened in this way as well.  In order to open
            LibUsb devices in this manner, an entry must be added to the driver
            inf file:
            <para>[Install.HW]</para>
            <para>Addreg=Add_LibUsb_Guid_Reg</para>
            <para>[Add_LibUsb_Guid_Reg]</para>
            <para>HKR,,LibUsbInterfaceGUIDs,0x10000,"{Your-Unique-Guid-String}"</para>
            </remarks>
            <param name="devInterfaceGuid">Device Interface GUID of the usb device to open.</param>
            <param name="usbDevice">On success, a new <see cref="T:LibUsbDotNet.UsbDevice"/> instance.</param>
            <returns>True on success.</returns>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.AllWinUsbDevices">
            <summary>
            Gets a list of all available WinUSB USB devices.
            </summary>
            <remarks>
            On windows, gets a list of WinUSB devices. On linux always returns null.
            <para>
            Using the <see cref="P:LibUsbDotNet.UsbDevice.AllDevices"/> property instead will ensure your source code is platform-independent.
            </para>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.HasLibUsbDriver">
            <summary>
            True if the LibUsb driver is found on the system.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.HasWinUsbDriver">
            <summary>
            True if the WinUSB API is available.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.HasLibUsbWinBackDriver">
            <summary>
            True if the libusb-1.0 API is available.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.IsLinux">
            <summary>
             Returns true if the system is a linux/unix-like operating system. 
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.KernelType">
            <summary>
            Gets the kernel driver type in use by LibUsbDotNet. 
            If <see cref="F:LibUsbDotNet.LibUsb.LibUsbKernelType.NativeLibUsb"/> is returned, LibUsbDotNet using using its
            native kernel driver.  Basic usb device information is retreived from the windows registry
            which reduces USB IO overhead. 
            If <see cref="F:LibUsbDotNet.LibUsb.LibUsbKernelType.LegacyLibUsb"/> is returned, LibUsbDotNet is using the orginal kernel
            available at the libusb-win32.sourceforge.net page and true windows registry support
            is unavailable.
            Under linux, <see cref="F:LibUsbDotNet.LibUsb.LibUsbKernelType.MonoLibUsb"/> is always returned.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.KernelVersion">
            <summary>
            Gets the kernel driver version in use by LibUsbDotNet.
            <alert class="note"><para>
            if <see cref="F:LibUsbDotNet.Main.UsbKernelVersion.BcdLibUsbDotNetKernelMod"/> is non-zero then the kernel driver is native.
            </para></alert>
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.OSVersion">
            <summary>
             Gets a <see cref="T:System.OperatingSystem"/> object that contains the current platform identifier and version number.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.Configs">
            <summary>
             Gets all available configurations for this <see cref="T:LibUsbDotNet.UsbDevice"/>
            </summary>
             <remarks>
             The first time this property is accessed it will query the <see cref="T:LibUsbDotNet.UsbDevice"/> for all configurations.
             Subsequent request will return a cached copy of all configurations.
             </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.Info">
            <summary>
            Gets the actual device descriptor the the current <see cref="T:LibUsbDotNet.UsbDevice"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.UsbRegistryInfo">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class that opened the device, or null if the device was not opened by the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.IsOpen">
            <summary>
            Gets a value indication if the device handle is valid.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.ActiveEndpoints">
            <summary>
            A list of endpoints that have beened opened by this <see cref="T:LibUsbDotNet.UsbDevice"/> class.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.DriverMode">
            <summary>
            Returns the DriverMode this USB device is using.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.AllDevices">
            <summary>
            Gets a list of all available USB devices (WinUsb, LibUsb, Linux LibUsb v1.x).
            </summary>
            <remarks>
            Use this property to get a list of USB device that can be accessed by LibUsbDotNet.
            Using this property as opposed to <see cref="P:LibUsbDotNet.UsbDevice.AllLibUsbDevices"/> and <see cref="P:LibUsbDotNet.UsbDevice.AllWinUsbDevices"/>
            will ensure your source code is platform-independent.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.AllLibUsbDevices">
            <summary>
            Gets a list of all available libusb-win32 USB devices.
            </summary>
            <remarks>
            <para>
            On windows, gets a list of libusb-win32 USB devices . If <see cref="F:LibUsbDotNet.UsbDevice.ForceLibUsbWinBack"/> 
            is true, gets a list of libusb-1.0 devices.
            </para>
            <para>
            On linux/mac, gets a list of libusb-1.0 devices.
            </para>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.LastErrorNumber">
            <summary>
            Returns the last error number reported by LibUsbDotNet.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbDevice.LastErrorString">
            <summary>
            Returns the last error string reported by LibUsbDotNet.
            </summary>
        </member>
        <member name="E:LibUsbDotNet.UsbDevice.UsbErrorEvent">
             <summary>
             Global static error event for all Usb errors.
             </summary>
             <example>
             Sample code to reset an endpoint if a critical error occurs.
             <code>
             // Hook the usb error handler function
             UsbGlobals.UsbErrorEvent += UsbErrorEvent;
            private void UsbErrorEvent(object sender, UsbError e)
            {
             // If the error is from a usb endpoint
             if (sender is UsbEndpointBase)
             {
                 // If the endpoint transfer failed
                 if (e.Win32ErrorNumber == 31)
                 {
                     // If the USB device is still open, connected, and valid
                     if (usb.IsOpen)
                     {
                         // Try to reset then endpoint
                         if (((UsbEndpointBase) sender).Reset())
                         {
                             // Endpoint reset successful.
                             // Tell LibUsbDotNet to ignore this error and continue.
                             e.Handled = true;
                         }
                     }
                 }
             }
             }
             </code>
             </example>
        </member>
        <member name="T:LibUsbDotNet.UsbDevice.DriverModeType">
            <summary>
            Driver modes enumeration. See the UsbDevice.<see cref="P:LibUsbDotNet.UsbDevice.DriverMode"/> property.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.UsbDevice.DriverModeType.Unknown">
            <summary>
            Not yet determined.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.UsbDevice.DriverModeType.LibUsb">
            <summary>
            Using LibUsb kernel driver (Legacy or Native) on windows.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.UsbDevice.DriverModeType.WinUsb">
            <summary>
            Using WinUsb user-mode driver on windows.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.UsbDevice.DriverModeType.MonoLibUsb">
            <summary>
            Using Libusb 1.0 driver on linux.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.UsbDevice.DriverModeType.LibUsbWinBack">
            <summary>
            Using Libusb 1.0 windows backend driver on windows.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.IUsbDevice">
            <summary>
            The <see cref="T:LibUsbDotNet.IUsbDevice"/> interface contains members needed to configure a USB device for use. 
            </summary>
            <remarks>
            Only "whole" usb devices have a <see cref="T:LibUsbDotNet.IUsbDevice"/> interface such as a 
            <see cref="T:LibUsbDotNet.LibUsb.LibUsbDevice"/> or a <see cref="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice"/>. This indicates
            the USB device must be properly configured by the user before it can be used.
            Partial or interfaces of devices such as a <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/> do not have an <see cref="T:LibUsbDotNet.IUsbDevice"/> 
            interface. This indicates that the driver is handling device configuration.
            </remarks>
            <example>
            This example uses the <see cref="T:LibUsbDotNet.IUsbDevice"/> interface to select the desired configuration and interface
            for usb devices that require it.
            <code source="..\Examples\Read.Write\ReadWrite.cs" lang="cs"/>
            </example>
        </member>
        <member name="T:LibUsbDotNet.IUsbInterface">
            <summary>
            The <see cref="T:LibUsbDotNet.IUsbInterface"/> interface contains members needed communicate with an 
            interface of a usb device. 
            </summary>
            <remarks>
            All USB device classes implement these members.
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.Close">
            <summary>
            Closes and frees device resources.  Once closed the device cannot be reopened.  A new <see cref="T:LibUsbDotNet.UsbDevice"/> class must be obtained using the <see cref="T:LibUsbDotNet.UsbGlobals"/> class.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.ControlTransfer(LibUsbDotNet.Main.UsbSetupPacket@,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Sends/Receives an IO control message to endpoint 0.
            </summary>
            <param name="setupPacket">Contains parameters for the control request. See section 9.3 USB Device Requests of the Universal Serial Bus Specification Revision 2.0 for more information. </param>
            <param name="buffer">Data to be sent/received from the device.</param>
            <param name="bufferLength">Length of the buffer param.</param>
            <param name="lengthTransferred">Number of bytes sent or received (depends on the direction of the control transfer).</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.ControlTransfer(LibUsbDotNet.Main.UsbSetupPacket@,System.Object,System.Int32,System.Int32@)">
            <summary>
            Transmits io control message to endpoint 0.
            </summary>
            <param name="setupPacket">Contains parameters for the control request. See section 9.3 USB Device Requests of the Universal Serial Bus Specification Revision 2.0 for more information. </param>
            <param name="buffer">Data to be sent/received from the device.  Th</param>
            <param name="bufferLength">Length of the buffer param.</param>
            <param name="lengthTransferred">Number of bytes sent or received (depends on the direction of the control transfer).</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.GetDescriptor(System.Byte,System.Byte,System.Int16,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Gets a specific descriptor from the device. See <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> for more information.
            </summary>
            <param name="descriptorType">The descriptor type ID to retrieve; this is usually one of the <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> enumerations.</param>
            <param name="index">Descriptor index.</param>
            <param name="langId">Descriptor language id.</param>
            <param name="buffer">Memory to store the returned descriptor in.</param>
            <param name="bufferLength">Length of the buffer parameter in bytes.</param>
            <param name="transferLength">The number of bytes transferred to buffer upon success.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.GetDescriptor(System.Byte,System.Byte,System.Int16,System.Object,System.Int32,System.Int32@)">
            <summary>
            Gets a specific descriptor from the device. See <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> for more information.
            </summary>
            <param name="descriptorType">The descriptor type ID to retrieve; this is usually one of the <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> enumerations.</param>
            <param name="index">Descriptor index.</param>
            <param name="langId">Descriptor language id.</param>
            <param name="buffer">Memory to store the returned descriptor in.</param>
            <param name="bufferLength">Length of the buffer parameter in bytes.</param>
            <param name="transferLength">The number of bytes transferred to buffer upon success.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.GetLangIDs(System.Int16[]@)">
            <summary>
            Asking for the zero'th index is special - it returns a string
            descriptor that contains all the language IDs supported by the
            device. Typically there aren't many - often only one. The
            language IDs are 16 bit numbers, and they start at the third byte
            in the descriptor. See USB 2.0 specification, section 9.6.7, for
            more information on this. 
            </summary>
            <returns>A collection of LCIDs that the current <see cref="T:LibUsbDotNet.UsbDevice"/> supports.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.GetString(System.String@,System.Int16,System.Byte)">
            <summary>
            Gets a string descriptor from the device.
            </summary>
            <param name="stringData">Buffer to store the returned string in upon success.</param>
            <param name="langId">The language ID to retrieve the string in. (0x409 for english).</param>
            <param name="stringIndex">The string index to retrieve.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.Open">
            <summary>
             Opens/re-opens this USB device instance for communication.
            </summary>
            <returns>True if the device is already opened or was opened successfully.  False if the device does not exists or is no longer valid.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID,System.Int32)">
            <summary>
            Opens a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> endpoint for reading
            </summary>
            <param name="readEndpointID">Endpoint number for read operations.</param>
            <param name="readBufferSize">Size of the read buffer allocated for the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class ready for reading. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID,System.Int32,LibUsbDotNet.Main.EndpointType)">
            <summary>
            Opens an endpoint for reading
            </summary>
            <param name="readEndpointID">Endpoint number for read operations.</param>
            <param name="readBufferSize">Size of the read buffer allocated for the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.</param>
            <param name="endpointType">The type of endpoint to open.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class ready for reading. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID)">
            <summary>
            Opens a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> endpoint for reading
            </summary>
            <param name="readEndpointID">Endpoint number for read operations.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class ready for reading. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.OpenEndpointWriter(LibUsbDotNet.Main.WriteEndpointID)">
            <summary>
            Opens a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> endpoint for writing
            </summary>
            <param name="writeEndpointID">Endpoint number for read operations.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class ready for writing. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbInterface.OpenEndpointWriter(LibUsbDotNet.Main.WriteEndpointID,LibUsbDotNet.Main.EndpointType)">
            <summary>
            Opens an endpoint for writing
            </summary>
            <param name="writeEndpointID">Endpoint number for read operations.</param>
            <param name="endpointType">The type of endpoint to open.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class ready for writing. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class is returned.</returns>
        </member>
        <member name="P:LibUsbDotNet.IUsbInterface.ActiveEndpoints">
            <summary>
            A list of endpoints that have beened opened by this <see cref="T:LibUsbDotNet.UsbDevice"/> class.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.IUsbInterface.Configs">
            <summary>
             Gets the available configurations for this <see cref="T:LibUsbDotNet.UsbDevice"/>
            </summary>
             <remarks>
             The first time this property is accessed it will query the <see cref="T:LibUsbDotNet.UsbDevice"/> for all configurations.  Subsequent request will return a cached copy of all configurations.
             </remarks>
        </member>
        <member name="P:LibUsbDotNet.IUsbInterface.DriverMode">
            <summary>
            Returns the DriverMode this USB device is using.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.IUsbInterface.Info">
            <summary>
            Gets the actual device descriptor the the current <see cref="T:LibUsbDotNet.UsbDevice"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.IUsbInterface.IsOpen">
            <summary>
            Gets a value indication if the device handle is valid.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.IUsbInterface.UsbRegistryInfo">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class that opened the device, or null if the device was not opened by the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.IUsbDevice.SetConfiguration(System.Byte)">
            <summary>
            Sets the USB devices active configuration value. 
            </summary>
            <param name="config">The active configuration value. A zero value means the device is not configured and a non-zero value indicates the device is configured.</param>
            <returns>True on success.</returns>
            <remarks>
            A USB device can have several different configurations, but only one active configuration.
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.IUsbDevice.GetConfiguration(System.Byte@)">
            <summary>
            Gets the USB devices active configuration value. 
            </summary>
            <param name="config">The active configuration value. A zero value means the device is not configured and a non-zero value indicates the device is configured.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbDevice.SetAltInterface(System.Int32)">
            <summary>
            Sets an alternate interface for the most recent claimed interface.
            </summary>
            <param name="alternateID">The alternate interface to select for the most recent claimed interface See <see cref="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ClaimInterface(System.Int32)"/>.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbDevice.GetAltInterfaceSetting(System.Byte,System.Byte@)">
            <summary>
            Gets the selected alternate interface of the specified interface.
            </summary>
            <param name="interfaceID">The interface settings number (index) to retrieve the selected alternate interface setting for.</param>
            <param name="selectedAltInterfaceID">The alternate interface setting selected for use with the specified interface.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbDevice.ClaimInterface(System.Int32)">
            <summary>
            Claims the specified interface of the device.
            </summary>
            <param name="interfaceID">The interface to claim.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbDevice.ReleaseInterface(System.Int32)">
            <summary>
            Releases an interface that was previously claimed with <see cref="M:LibUsbDotNet.IUsbDevice.ClaimInterface(System.Int32)"/>.
            </summary>
            <param name="interfaceID">The interface to release.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.IUsbDevice.ResetDevice">
            <summary>
            Sends a usb device reset command.
            </summary>
            <remarks>
            After calling <see cref="M:LibUsbDotNet.IUsbDevice.ResetDevice"/>, the <see cref="T:LibUsbDotNet.UsbDevice"/> instance is disposed and
            no longer usable.  A new <see cref="T:LibUsbDotNet.UsbDevice"/> instance must be obtained from the device list.
            </remarks>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.Open">
            <summary>
             Opens the USB device handle.
            </summary>
            <returns>
            True if the device is already opened or was opened successfully.
            False if the device does not exists or is no longer valid.  
            </returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.ClaimInterface(System.Int32)">
            <summary>
            Claims the specified interface of the device.
            </summary>
            <param name="interfaceID">The interface to claim.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.Close">
            <summary>
            Closes the <see cref="T:LibUsbDotNet.UsbDevice"/> and disposes any <see cref="P:LibUsbDotNet.UsbDevice.ActiveEndpoints"/>.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.ReleaseInterface(System.Int32)">
            <summary>
            Releases an interface that was previously claimed with <see cref="M:LibUsbDotNet.LibUsb.LibUsbDevice.ClaimInterface(System.Int32)"/>.
            </summary>
            <param name="interfaceID">The interface to release.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.SetAltInterface(System.Int32)">
            <summary>
            Sets an alternate interface for the most recent claimed interface.
            </summary>
            <param name="alternateID">The alternate interface to select for the most recent claimed interface See <see cref="M:LibUsbDotNet.LibUsb.LibUsbDevice.ClaimInterface(System.Int32)"/>.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.SetConfiguration(System.Byte)">
            <summary>
            Sets the USB devices active configuration value. 
            </summary>
            <param name="config">The active configuration value. A zero value means the device is not configured and a non-zero value indicates the device is configured.</param>
            <returns>True on success.</returns>
            <remarks>
            A USB device can have several different configurations, but only one active configuration.
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.Open(System.String,LibUsbDotNet.LibUsb.LibUsbDevice@)">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <param name="deviceFilename">The LibUsb device filename to open.</param>
            <param name="usbDevice">The newly created UsbDevice.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.ReleaseAllInterfaces">
            <summary>
            Releases all interface claimed by <see cref="M:LibUsbDotNet.LibUsb.LibUsbDevice.ClaimInterface(System.Int32)"/>.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.ReleaseInterface">
            <summary>
            Releases the last interface claimed by <see cref="M:LibUsbDotNet.LibUsb.LibUsbDevice.ClaimInterface(System.Int32)"/>.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.SetAltInterface(System.Int32,System.Int32)">
            <summary>
            Sets an alternate interface for the specified interface.
            </summary>
            <param name="interfaceID">The interface index to specify an alternate setting for.</param>
            <param name="alternateID">The alternate interface setting.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbDevice.ResetDevice">
            <summary>
            Sends a usb device reset command.
            </summary>
            <remarks>
            After calling <see cref="M:LibUsbDotNet.LibUsb.LibUsbDevice.ResetDevice"/>, the <see cref="T:LibUsbDotNet.LibUsb.LibUsbDevice"/> instance is disposed and
            no longer usable.  A new <see cref="T:LibUsbDotNet.LibUsb.LibUsbDevice"/> instance must be obtained from the device list.
            </remarks>
            <returns>True on success.</returns>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbDevice.LegacyLibUsbDeviceList">
            <summary>
            Gets a list of libusb devices directly from the kernel; bypassing the windows registry.  
            This function is intended for users that do not use the native kernel driver.  
            If using the native kernel (sys) driver supplied with LibUsbDotNet see the <see cref="P:LibUsbDotNet.UsbDevice.AllDevices"/>.
            <seealso cref="T:LibUsbDotNet.UsbGlobals"/>
            <seealso cref="P:LibUsbDotNet.UsbDevice.AllLibUsbDevices"/>
            <seealso cref="P:LibUsbDotNet.UsbDevice.AllWinUsbDevices"/>
            <seealso cref="M:LibUsbDotNet.UsbDevice.OpenUsbDevice(LibUsbDotNet.Main.UsbDeviceFinder)"/>
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbDevice.DeviceFilename">
            <summary>
            Gets the Device filename for this device.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbDevice.DriverMode">
            <summary>
            Returns the DriverMode this USB device is using.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Transfer.MonoUsbControlSetup">
            <summary>
            Reads/writes a Libusb-1.0 control setup packet pointer.  Control setup packets should be allocated with <see cref="T:MonoLibUsb.Transfer.MonoUsbControlSetupHandle"/>.
            </summary>
            <remarks>
            <para>This class that reads and writes values directly from/to the setup packet <see cref="T:System.IntPtr"/> using <see cref="T:System.Runtime.InteropServices.Marshal"/>.</para>
            <note type="tip">This type is used for asynchronous control transfers only.</note>
            </remarks>
            <seealso cref="T:MonoLibUsb.Transfer.MonoUsbControlSetupHandle"/>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbControlSetup.SETUP_PACKET_SIZE">
            <summary>
            Size of a Libusb-1.0 setup packet.
            </summary>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbControlSetup.#ctor(System.IntPtr)">
            <summary>
            Creates a <see cref="T:MonoLibUsb.Transfer.MonoUsbControlSetup"/> structure for a control setup packet pointer.
            </summary>
            <remarks>
            The <paramref name="pControlSetup"/> pointer must be a pointer in memory to a valid Libusb-1.0 <a href="http://libusb.sourceforge.net/api-1.0/structlibusb__control__setup.html">libusb__control__setup</a> that was allocated with <see cref="T:MonoLibUsb.Transfer.MonoUsbControlSetupHandle"/>.
            </remarks>
            <param name="pControlSetup">Pointer to the setup packet.  This will usually be <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.PtrBuffer">MonoUsbTransfer.PtrBuffer</see></param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbControlSetup.SetData(System.Object,System.Int32,System.Int32)">
            <summary>
            Copies data into <see cref="P:MonoLibUsb.Transfer.MonoUsbControlSetup.PtrData"/>.
            </summary>
            <param name="data">
            <para>Data buffer to copy into <see cref="P:MonoLibUsb.Transfer.MonoUsbControlSetup.PtrData"/>for an output control transfer.</para>
            This value can be:
            <list type="bullet">
            <item>An <see cref="T:System.Array"/> of bytes or other <a href="http://msdn.microsoft.com/en-us/library/75dwhxf7.aspx">blittable</a> types.</item>
            <item>An already allocated, pinned <see cref="T:System.Runtime.InteropServices.GCHandle"/>. In this case <see cref="M:System.Runtime.InteropServices.GCHandle.AddrOfPinnedObject"/> is used for the buffer address.</item>
            <item>An <see cref="T:System.IntPtr"/>.</item>
            </list>
            </param>
            <param name="offset">The offset in <paramref name="data"/> to begin copying.</param>
            <param name="length">Number of to copy.</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbControlSetup.GetData(System.Int32)">
            <summary>
            Gets control data as bytes.
            </summary>
            <param name="transferLength">The number of bytes to copy out of <see cref="P:MonoLibUsb.Transfer.MonoUsbControlSetup.PtrData"/>. This will usually come from <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.ActualLength">MonoUsbTransfer.ActualLength</see>.</param>
            <returns>A new byte array of control data.</returns>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbControlSetup.RequestType">
            <summary>
            The request type.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbControlSetup.Request">
            <summary>
            The request.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbControlSetup.Value">
            <summary>
            The wValue.
            </summary>
            <remarks>
            <note type="tip">The get/set accessors automatically manage the little-endian to host-endian/host-endian to little-endian conversions using the <see cref="M:LibUsbDotNet.Main.Helper.HostEndianToLE16(System.Int16)"/> method.</note>
            </remarks>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbControlSetup.Index">
            <summary>
            The wIndex.
            </summary>
            <remarks>
            <note type="tip">The get/set accessors automatically manage the little-endian to host-endian/host-endian to little-endian conversions using the <see cref="M:LibUsbDotNet.Main.Helper.HostEndianToLE16(System.Int16)"/> method.</note>
            </remarks>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbControlSetup.Length">
            <summary>
            Number of bytes to transfer. 
            </summary>
            <remarks>
            <note type="tip">The get/set accessors automatically manage the little-endian to host-endian/host-endian to little-endian conversions using the <see cref="M:LibUsbDotNet.Main.Helper.HostEndianToLE16(System.Int16)"/> method.</note>
            </remarks>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbControlSetup.PtrData">
            <summary>
            Gets a pointer to the control data buffer.
            </summary>
            <remarks>This is the <see cref="T:System.IntPtr"/> to the control data inside of the setup packet, not to the setup packet itself.</remarks>
        </member>
        <member name="T:LibUsbDotNet.Info.UsbConfigInfo">
            <summary> Contains all Configuration information for the current <see cref="T:LibUsbDotNet.UsbDevice"/>.
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.Info.UsbBaseInfo">
            <summary> Base class for all Usb descriptors.
                    <see cref="T:LibUsbDotNet.Info.UsbConfigInfo"/>, <see cref="T:LibUsbDotNet.Info.UsbEndpointInfo"/>, <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/></summary>
            <remarks><p>LibUsbDotNet supports and parses all the basic usb descriptors.</p><p>
                      Unknown descriptors such as driver specific class descriptors are stored as byte arrays and are accessible from the <see cref="P:LibUsbDotNet.Info.UsbBaseInfo.CustomDescriptors"/> property.
                    </p></remarks>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbBaseInfo.CustomDescriptors">
            <summary>
            Gets the device-specific custom descriptor lists.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Info.UsbConfigInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbConfigInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbConfigInfo"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Info.UsbConfigInfo.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbConfigInfo"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Info.UsbConfigInfo"/>.</returns>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbConfigInfo.Descriptor">
            <summary>
            Gets the actual <see cref="T:LibUsbDotNet.Descriptors.UsbConfigDescriptor"/> for the current config.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbConfigInfo.ConfigString">
            <summary>
            Gets the string representation of the <see cref="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.StringIndex"/> string index.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbConfigInfo.InterfaceInfoList">
            <summary>
            Gets the collection of USB device interfaces associated with this <see cref="T:LibUsbDotNet.Info.UsbConfigInfo"/> instance.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.EventType">
            <summary> 
            Type of notification event.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.EventType.CustomEvent">
            <summary>
            A custom event has occurred.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.EventType.DeviceArrival">
            <summary>
            A device or piece of media has been inserted and is now available.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.EventType.DeviceQueryRemove">
            <summary>
            Permission is requested to remove a device or piece of media. Any application can deny this request and cancel the removal.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.EventType.DeviceQueryRemoveFailed">
            <summary>
            A request to remove a device or piece of media has been canceled.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.EventType.DeviceRemoveComplete">
            <summary>
            A device or piece of media has been removed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.EventType.DeviceRemovePending">
            <summary>
            A device or piece of media is about to be removed. Cannot be denied.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.EventType.DeviceTypeSpecific">
            <summary>
            A device-specific event has occurred.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.UsbGlobals">
            <summary> 
            Static class for opening, enumerating and finding USB devices.  
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.Main.UsbEndpointList">
            <summary> Endpoint list.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointList.GetEnumerator">
            <summary>
            Returns <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> enumerator that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointList.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"/> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointList.Clear">
            <summary>
            Removes all items from the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointList.Contains(LibUsbDotNet.Main.UsbEndpointBase)">
            <summary>
            Determines whether the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/> contains a specific value.
            </summary>
            
            <returns>
            true if item is found in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>; otherwise, false.
            </returns>
            
            <param name="item">The <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> to locate in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointList.IndexOf(LibUsbDotNet.Main.UsbEndpointBase)">
            <summary>
            Determines the index of a specific <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.
            </summary>
            
            <returns>
            The index of item if found in the list; otherwise, -1.
            </returns>
            
            <param name="item">The <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> to locate in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointList.Remove(LibUsbDotNet.Main.UsbEndpointBase)">
            <summary>
            Removes the specified <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.
            </summary>
            
            <param name="item">The <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> to remove in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbEndpointList.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/> item at the specified index.
            </summary>
            
            <param name="index">The zero-based index of the item to remove.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.</exception>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbEndpointList.Item(System.Int32)">
             <summary>
             Gets the <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> item at the specified index.
             </summary>
             <param name="index">The zero-based index of the item.</param>
             <returns>The <see cref="T:LibUsbDotNet.Main.UsbEndpointBase"/> item at the specified index.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">index is not a valid index in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.</exception>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbEndpointList.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:LibUsbDotNet.Main.UsbEndpointList"/>.
            </returns>
            
        </member>
        <member name="T:LibUsbDotNet.UsbError">
            <summary> Describes a Usb error or setup API error.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.UsbError.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.UsbError"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.UsbError"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.UsbError.Sender">
            <summary>
            The sender of the exception.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbError.ErrorCode">
            <summary>
            Gets the general errorcode.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbError.Win32ErrorNumber">
            <summary>
            Gets the Windows specific error number.  Only valid when <see cref="P:LibUsbDotNet.UsbError.ErrorCode"/> is set to <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.Win32Error"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbError.Description">
            <summary>
            Gets the general description for the error.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.UsbError.Win32ErrorString">
            <summary>
            Gets the Windows specific error string. Only valid when <see cref="P:LibUsbDotNet.UsbError.ErrorCode"/> is set to <see cref="T:LibUsbDotNet.Main.ErrorCode"/>.<see cref="F:LibUsbDotNet.Main.ErrorCode.Win32Error"/>.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Internal.SafeOverlapped.ClearAndSetEvent(System.IntPtr)">
            <summary>
            Set the overlapped wait handle and clear out the rest of the structure.
            </summary>
            <param name="hEventOverlapped"></param>
        </member>
        <member name="P:LibUsbDotNet.Internal.SafeOverlapped.EventHandle">
            <summary>
            The overlapped event wait hande.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Internal.SafeOverlapped.GlobalOverlapped">
            <summary>
            Pass this into the DeviceIoControl and GetOverlappedResult APIs
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.LegacyUsbRegistry">
            <summary> 
            LibUsb specific members for device registry settings.  
            This legacy class does not actually query the windows registry as the other Registry classes do. 
            Instead, it wraps a <see cref="T:LibUsbDotNet.LibUsb.LibUsbDevice"/> and queries descriptors directly from the device 
            using usb IO control messages.
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.Main.UsbRegistry">
            <summary> USB device registry members common to both LibUsb and WinUsb devices.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRegistry.ForceSetupApi">
            <summary>
            If true, LibUsbDotNet will use the vid, pid and revision of the <see cref="P:LibUsbDotNet.UsbDevice.Info"/> 
            descriptor to lookup additional device information in the windows registry via the setupapi.
            Setting this field to false will cause all device information to come directly from the 
            device descriptors.
            </summary>
            <remarks>
            <para>
            If using WinUSB or the LibUsbDotNet-libusb-win32 native driver, information provided by 
            the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class will come from the registry regardless of this setting
            because these drivers have direct support for this.
            </para>
            <para>
            The Libusb-1.0 windows-backend driver and the legacy libusb-win32 driver have their own methods
            for listing, finding, and opening devices.  For these drivers, the <see cref="F:LibUsbDotNet.Main.UsbRegistry.ForceSetupApi"/> can
            be set to do a "reverse lookup" via the setupapi using only the vid, pid and revision of the 
            <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>.  The <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class is then populated with
            all available <see cref="T:LibUsbDotNet.Main.SPDRP"/> properties, device interface guids, winusb device paths, etc.
            </para>
            </remarks>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRegistry.mDeviceInterfaceGuids">
            <summary>
            Guid array of all <see cref="P:LibUsbDotNet.Main.UsbRegistry.DeviceInterfaceGuids"/> assigned to this device.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbRegistry.Open(LibUsbDotNet.UsbDevice@)">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <param name="usbDevice">The newly created UsbDevice.</param>
            <returns>True on success.</returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.DeviceProperties">
            <summary>
            Collection of known usb device properties (from the registry).
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.IsAlive">
            <summary>
            Check this value to determine if the usb device is still connected to the bus and ready to open.
            </summary>
            <remarks>
            Uses the symbolic name as a unique id to determine if this device instance is still attached.
            </remarks>
            <exception cref="T:LibUsbDotNet.Main.UsbException">An exception is thrown if the <see cref="P:LibUsbDotNet.Main.UsbRegistry.SymbolicName"/> property is null or empty.</exception>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.SymbolicName">
            <summary>
            The unique "SymbolicName" of the device.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.DeviceInterfaceGuids">
            <summary>
            The unique "SymbolicName" of the device.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Vid">
            <summary>
            VendorID
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Pid">
            <summary>
            ProductID
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Item(System.String)">
            <summary>
            Gets a device property/key from the registry.
            </summary>
            <param name="name">The name of the property to retrieve.</param>
            <returns></returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Item(LibUsbDotNet.Main.SPDRP)">
            <summary>
            Gets a device property/key from the registry.  See the <see cref="T:LibUsbDotNet.Main.SPDRP"/> enumeration for more information.
            </summary>
            <param name="spdrp">The name of the property to retrieve.</param>
            <returns></returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Item(LibUsbDotNet.Main.DevicePropertyType)">
            <summary>
            Gets a property from the registry.  See the <see cref="T:LibUsbDotNet.Main.DevicePropertyType"/> enumeration for more information.
            </summary>
            <param name="devicePropertyType">The name of the property to retrieve.</param>
            <returns></returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Name">
            <summary>
            Gets the short name of the usb device.
            </summary>
            <remarks>This is the device decription as it is defined in the setup/inf file.</remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.FullName">
            <summary>
            Gets the manufacturer followed by the device decription in the format 'Mfu - Description'
            </summary>
            <remarks>This property works best for a display name.  It does additional proccessing on the manufacturer and device description that make it more user readable.</remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Count">
            <summary>
            Number of properties in the array.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Rev">
            <summary>
            Usb device revision number.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbRegistry.Device">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <returns>Return a new instance of the <see cref="T:LibUsbDotNet.UsbDevice"/> class.
            If the device fails to open a null refrence is return. For extended error
            information see the <see cref="E:LibUsbDotNet.UsbDevice.UsbErrorEvent"/>.
             </returns>
        </member>
        <member name="M:LibUsbDotNet.Main.LegacyUsbRegistry.Open(LibUsbDotNet.UsbDevice@)">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <param name="usbDevice">The newly created UsbDevice.</param>
            <returns>True on success.</returns>
        </member>
        <member name="P:LibUsbDotNet.Main.LegacyUsbRegistry.Device">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <returns>Return a new instance of the <see cref="T:LibUsbDotNet.UsbDevice"/> class.
            If the device fails to open a null refrence is return. For extended error
            information use the <see cref="E:LibUsbDotNet.UsbDevice.UsbErrorEvent"/>.
             </returns>
        </member>
        <member name="P:LibUsbDotNet.Main.LegacyUsbRegistry.DeviceInterfaceGuids">
            <summary>
            Gets the DeviceInterfaceGuids for the WinUsb device.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.LegacyUsbRegistry.IsAlive">
            <summary>
            Check this value to determine if the usb device is still connected to the bus and ready to open.
            </summary>
            <remarks>
            Uses the symbolic name as a unique id to determine if this device instance is still attached.
            </remarks>
            <exception cref="T:LibUsbDotNet.Main.UsbException">An exception is thrown if the <see cref="P:LibUsbDotNet.Main.UsbRegistry.SymbolicName"/> property is null or empty.</exception>
        </member>
        <member name="P:LibUsbDotNet.Main.LegacyUsbRegistry.DeviceList">
             <summary>
             Gets a list of available LibUsb devices.
             </summary>
            
        </member>
        <member name="P:LibUsbDotNet.Main.LegacyUsbRegistry.Rev">
            <summary>
            Usb device revision number.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor">
            <summary>
            A structure representing the standard USB endpoint descriptor. This
            descriptor is documented in section 9.6.3 of the USB 2.0 specification.
            All multiple-byte fields are represented in host-endian format.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.bLength">
            <summary> Size of this descriptor (in bytes)</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.bDescriptorType">
            <summary> Descriptor type. Will have value LIBUSB_DT_ENDPOINT in this context.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.bEndpointAddress">
            <summary> The address of the endpoint described by this descriptor. Bits 0:3 are the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction, see \ref libusb_endpoint_direction.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.bmAttributes">
            <summary> Attributes which apply to the endpoint when it is configured using the bConfigurationValue. Bits 0:1 determine the transfer type and correspond to \ref libusb_transfer_type. Bits 2:3 are only used for isochronous endpoints and correspond to \ref libusb_iso_sync_type. Bits 4:5 are also only used for isochronous endpoints and correspond to \ref libusb_iso_usage_type. Bits 6:7 are reserved.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.wMaxPacketSize">
            <summary> Maximum packet size this endpoint is capable of sending/receiving.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.bInterval">
            <summary> Interval for polling endpoint for data transfers.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.bRefresh">
            <summary> For audio devices only: the rate at which synchronization feedback is provided.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.bSynchAddress">
            <summary> For audio devices only: the address if the synch endpoint</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.pExtraBytes">
            <summary> Extra descriptors. If libusb encounters unknown endpoint descriptors, it will store them here, should you wish to parse them.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.ExtraLength">
            <summary> Length of the extra descriptors, in bytes.</summary>
        </member>
        <member name="P:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.ExtraBytes">
            <summary> Extra descriptors. If libusb encounters unknown endpoint descriptors, it will store them here, should you wish to parse them.</summary>
        </member>
        <member name="T:MonoLibUsb.Profile.AddRemoveEventArgs">
            <summary>
            Describes a device arrival/removal notification event
            </summary>
        </member>
        <member name="P:MonoLibUsb.Profile.AddRemoveEventArgs.MonoUSBProfile">
            <summary>
            The <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> that was added or removed.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Profile.AddRemoveEventArgs.EventType">
            <summary>
            The type of event that occured.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs">
            <summary>
            Describes the device notify event
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.Volume">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.DeviceNotify.Info.VolumeNotifyInfo"/> class.
            </summary>
            <remarks>
            This value is null if the <see cref="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.DeviceType"/> is not set to <see cref="F:LibUsbDotNet.DeviceNotify.DeviceType.Volume"/>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.Port">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo"/> class.
            </summary>
            <remarks>
            This value is null if the <see cref="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.DeviceType"/> is not set to <see cref="F:LibUsbDotNet.DeviceNotify.DeviceType.Port"/>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.Device">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo"/> class.
            </summary>
            <remarks>
            This value is null if the <see cref="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.DeviceType"/> is not set to <see cref="F:LibUsbDotNet.DeviceNotify.DeviceType.DeviceInterface"/>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.EventType">
            <summary>
            Gets the <see cref="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.EventType"/> for this notification.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.DeviceType">
            <summary>
            Gets the <see cref="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.DeviceType"/> for this notification.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.DeviceNotifyEventArgs.Object">
            <summary>
            Gets the notification class as an object.
            </summary>
            <remarks>
            This value is never null.
            </remarks>
        </member>
        <member name="T:LibUsbDotNet.Descriptors.DescriptorType">
            <summary> Standard USB descriptor types.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Device">
            <summary>
            Device descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Configuration">
            <summary>
            Configuration descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.String">
            <summary>
            String descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Interface">
            <summary>
            Interface descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Endpoint">
            <summary>
            Endpoint descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.DeviceQualifier">
            <summary>
            Device Qualifier descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.OtherSpeedConfiguration">
            <summary>
            Other Speed Configuration descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.InterfacePower">
            <summary>
            Interface Power descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.OTG">
            <summary>
            OTG descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Debug">
            <summary>
            Debug descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.InterfaceAssociation">
            <summary>
            Interface Association descriptor type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Hid">
            <summary> HID descriptor</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.HidReport">
            <summary> HID report descriptor</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Physical">
            <summary> Physical descriptor</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.DescriptorType.Hub">
            <summary> Hub descriptor</summary>
        </member>
        <member name="T:LibUsbDotNet.Descriptors.ClassCodeType">
            <summary> Device and/or Interface Class codes</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.PerInterface">
            <summary>In the context of a "device descriptor", this bDeviceClass value indicates that each interface specifies its own class information and all interfaces operate independently.</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.Audio">
            <summary>Audio class</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.Comm">
            <summary> Communications class</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.Hid">
            <summary> Human Interface Device class</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.Printer">
            <summary> Printer dclass</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.Ptp">
            <summary> Picture transfer protocol class</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.MassStorage">
            <summary> Mass storage class</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.Hub">
            <summary> Hub class</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.Data">
            <summary> Data class</summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.ClassCodeType.VendorSpec">
            <summary> Class is vendor-specific</summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbException">
            <summary>
             Represents an exception generated by a USB operation.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.Main.UsbException.#ctor(System.Object,System.String)">
            <summary>
            LibUsbDotNet USB exception.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbException.Sender">
            <summary>
            The object that caused the exception.
            </summary>
        </member>
        <member name="T:MonoLibUsb.UnixNativeTimeval">
            <summary>
            Unix mono.net timeval structure.
            </summary>
        </member>
        <member name="M:MonoLibUsb.UnixNativeTimeval.#ctor(System.Int64,System.Int64)">
            <summary>
            Timeval constructor.
            </summary>
            <param name="tvSec">seconds</param>
            <param name="tvUsec">milliseconds</param>
        </member>
        <member name="P:MonoLibUsb.UnixNativeTimeval.WindowsDefault">
            <summary>
            Default <see cref="T:MonoLibUsb.UnixNativeTimeval"/> used by the <see cref="T:MonoLibUsb.MonoUsbEventHandler"/> on windows platforms.
            </summary>
        </member>
        <member name="P:MonoLibUsb.UnixNativeTimeval.LinuxDefault">
            <summary>
            Default <see cref="T:MonoLibUsb.UnixNativeTimeval"/> used by the <see cref="T:MonoLibUsb.MonoUsbEventHandler"/> on unix-like platforms.
            </summary>
        </member>
        <member name="P:MonoLibUsb.UnixNativeTimeval.Default">
            <summary>
            Default <see cref="T:MonoLibUsb.UnixNativeTimeval"/>.
            </summary>
        </member>
        <member name="P:MonoLibUsb.UnixNativeTimeval.tv_sec">
            <summary>
            Timeval seconds property.
            </summary>
        </member>
        <member name="P:MonoLibUsb.UnixNativeTimeval.tv_usec">
            <summary>
            Timeval milliseconds property.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbRequestType">
            <summary>
            Standard USB requests.
            </summary>
            <seealso cref="T:LibUsbDotNet.Main.UsbCtrlFlags"/>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestType.TypeClass">
            <summary>
            Class specific request.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestType.TypeReserved">
            <summary>
            RESERVED.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestType.TypeStandard">
            <summary>
            Standard request.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestType.TypeVendor">
            <summary>
            Vendor specific request.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor">
            <summary>
            A structure representing the standard USB interface descriptor. This
            descriptor is documented in section 9.6.5 of the USB 2.0 specification.
            All multiple-byte fields are represented in host-endian format.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bLength">
            <summary>Size of this descriptor (in bytes)</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bDescriptorType">
            <summary>Descriptor type. Will have value LIBUSB_DT_INTERFACE in this context.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bInterfaceNumber">
            <summary>Number of this interface</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bAlternateSetting">
            <summary>Value used to select this alternate setting for this interface</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bNumEndpoints">
            <summary> Number of endpoints used by this interface (excluding the control endpoint).</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bInterfaceClass">
            <summary> USB-IF class code for this interface. See ClassCodeType.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bInterfaceSubClass">
            <summary> USB-IF subclass code for this interface, qualified by the bInterfaceClass value</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bInterfaceProtocol">
            <summary> USB-IF protocol code for this interface, qualified by the bInterfaceClass and bInterfaceSubClass values</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.iInterface">
            <summary> Index of string descriptor describing this interface</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.pEndpointDescriptors">
            <summary> Array of endpoint descriptors. This length of this array is determined by the bNumEndpoints field.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.pExtraBytes">
            <summary> Extra descriptors. If libusb encounters unknown interface descriptors, it will store them here, should you wish to parse them.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.ExtraLength">
            <summary> Length of the extra descriptors, in bytes.</summary>
        </member>
        <member name="P:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.ExtraBytes">
            <summary> Extra descriptors. If libusb encounters unknown interface descriptors, it will store them here, should you wish to parse them.</summary>
        </member>
        <member name="P:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.EndpointList">
            <summary> Array of endpoint descriptors. This length of this array is determined by the bNumEndpoints field.</summary>
        </member>
        <member name="T:LibUsbDotNet.Info.UsbInterfaceInfo">
            <summary> Describes a USB device interface.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.Info.UsbInterfaceInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Info.UsbInterfaceInfo.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.</returns>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbInterfaceInfo.Descriptor">
            <summary>
            Gets the actual interface descriptor.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbInterfaceInfo.EndpointInfoList">
            <summary>
            Gets the collection of endpoint descriptors associated with this interface.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbInterfaceInfo.InterfaceString">
            <summary>
            Gets the string representation of the <see cref="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.StringIndex"/> string index.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.WinUsb.WinUsbDevice">
            <summary> 
            Contains members specific to Microsofts WinUSB driver.
            </summary> 
            <remarks>
            A <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/> should be thought of as a part of, or an interface of a USB device.
            The <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/> class does not have members for selecting configurations and
            intefaces.  This is done at a lower level by the winusb driver depending on which interface the
            <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/> belongs to.
            </remarks> 
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.Close">
            <summary>
            Closes the <see cref="T:LibUsbDotNet.UsbDevice"/> and disposes any <see cref="P:LibUsbDotNet.UsbDevice.ActiveEndpoints"/>.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.Open">
            <summary>
             Opens the USB device handle.
            </summary>
            <returns>
            True if the device is already opened or was opened successfully.
            False if the device does not exists or is no longer valid.  
            </returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.Open(System.String,LibUsbDotNet.WinUsb.WinUsbDevice@)">
            <summary>
            Opens a WinUsb directly from the user supplied device path. 
            </summary>
            <param name="devicePath">Device path (symbolic link) of the WinUsb device to open.</param>
            <param name="usbDevice">Returns an opened WinUsb device on success, null on failure.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.EndpointPolicies(LibUsbDotNet.Main.ReadEndpointID)">
            <summary>
            Gets endpoint policies for the specified endpoint id.
            </summary>
            <param name="epNum">The endpoint ID to retrieve <see cref="T:LibUsbDotNet.WinUsb.PipePolicies"/> for.</param>
            <returns>A <see cref="T:LibUsbDotNet.WinUsb.PipePolicies"/> class.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.EndpointPolicies(LibUsbDotNet.Main.WriteEndpointID)">
            <summary>
            Gets endpoint policies for the specified endpoint id.
            </summary>
            <param name="epNum">The endpoint ID to retrieve <see cref="T:LibUsbDotNet.WinUsb.PipePolicies"/> for.</param>
            <returns>A <see cref="T:LibUsbDotNet.WinUsb.PipePolicies"/> class.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.GetAssociatedInterface(System.Byte,LibUsbDotNet.WinUsb.WinUsbDevice@)">
            <summary>
            Gets an interface associated with this <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/>.
            </summary>
            <param name="associatedInterfaceIndex">The index to retrieve. (0 = next interface, 1= interface after next, etc.).</param>
            <param name="usbDevice">A new <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/> class for the specified AssociatedInterfaceIndex.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.GetCurrentAlternateSetting(System.Byte@)">
            <summary>
            Gets the currently selected alternate settings number for the selected inteface.
            </summary>
            <param name="settingNumber">The selected AlternateSetting number.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.QueryDeviceSpeed(LibUsbDotNet.WinUsb.DeviceSpeedTypes@)">
            <summary>
            Gets the device speed.
            </summary>
            <param name="deviceSpeed">The device speed.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.QueryInterfaceSettings(System.Byte,LibUsbDotNet.Descriptors.UsbInterfaceDescriptor@)">
            <summary>
            Gets a <see cref="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor"/> for the specified AlternateInterfaceNumber,
            </summary>
            <param name="alternateInterfaceNumber">The alternate interface index for the <see cref="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor"/> to retrieve. </param>
            <param name="usbAltInterfaceDescriptor">The <see cref="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor"/> for the specified AlternateInterfaceNumber.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.GetDevicePathList(System.Guid,System.Collections.Generic.List{System.String}@)">
            <summary>
            Gets a list a valid, connected WinUSB device inteface paths for the a given WinUSB device interface guid.
            </summary>
            <param name="interfaceGuid">A WinUSB DeviceInterfaceGUID.  This is set in the usb devices inf file when the drivers for it are installed.</param>
            <param name="devicePathList">A list of connected WinUSB device inteface paths.</param>
            <returns>True if one or more device paths were found.  False if no devices are found or an error occured. <see cref="E:LibUsbDotNet.UsbDevice.UsbErrorEvent"/> </returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbDevice.Finalize">
            <summary>
            Closes the device. <see cref="M:LibUsbDotNet.WinUsb.WinUsbDevice.Close"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbDevice.PowerPolicy">
            <summary>
            Gets the power policies for this <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbDevice.DevicePath">
            <summary>
            Gets the device path used to open this <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbDevice.DriverMode">
            <summary>
            Returns the DriverMode this USB device is using.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbStandardRequest">
            <summary>
            Standard Device Requests.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.ClearFeature">
            <summary>
            Clear or disable a specific feature.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.GetConfiguration">
            <summary>
            Returns the current device Configuration value.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.GetDescriptor">
            <summary>
            Returns the specified descriptor if the descriptor exists.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.GetInterface">
            <summary>
            Returns the selected alternate setting for the specified interface.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.GetStatus">
            <summary>
            Returns status for the specified recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.SetAddress">
            <summary>
            Sets the device address for all future device accesses.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.SetConfiguration">
            <summary>
            Sets the device Configuration.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.SetDescriptor">
            <summary>
            Optional and may be used to update existing descriptors or new descriptors may be added.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.SetFeature">
            <summary>
            used to set or enable a specific feature.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.SetInterface">
            <summary>
            Allows the host to select an alternate setting for the specified interface.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStandardRequest.SynchFrame">
            <summary>
            Used to set and then report an endpoint’s synchronization frame.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.ErrorCode">
            <summary> 
            General area in which the failure occurred. See the <see cref="T:LibUsbDotNet.UsbError"/> class.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.None">
            <summary>
            No error. (None, Success, and Ok)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.Success">
            <summary>
            No error.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.Ok">
            <summary>
            No error.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.InvalidConfig">
            <summary>
            The USB device has errors in its Configuration descriptor.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.IoSyncFailed">
            <summary>
            A synchronous device IO operation failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.GetString">
            <summary>
            A request for a string failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.InvalidEndpoint">
            <summary>
            A specified endpoint is invalid for the operation.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.AbortEndpoint">
            <summary>
            A request to cancel IO operation failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.DeviceIoControl">
            <summary>
            A call to the core Win32 API DeviceIOControl failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.GetOverlappedResult">
            <summary>
            A call to the core Win32 API GetOverlappedResult failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.ReceiveThreadTerminated">
            <summary>
            An Endpoints receive thread was dangerously terminated.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.WriteFailed">
            <summary>
            A write operation failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.ReadFailed">
            <summary>
            A read operation failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.IoControlMessage">
            <summary>
            An endpoint 0 IO control message failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.CancelIoFailed">
            <summary>
            The action of cancelling the IO operation failed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.IoCancelled">
            <summary>
            An IO operation was cancelled by the user before it completed.
            </summary>
            <remarks>
            IoCancelled errors may occur as normal operation; for this reason they are not logged as a <see cref="T:LibUsbDotNet.UsbError"/>.
            </remarks>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.IoTimedOut">
            <summary>
            An IO operation timed out before it completed.
            </summary>
            <remarks>
            IoTimedOut errors may occur as normal operation; for this reason they are not logged as a <see cref="T:LibUsbDotNet.UsbError"/>.
            </remarks>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.IoEndpointGlobalCancelRedo">
            <summary>
            An IO operation was cancelled and will be re-submiited when ready.
            </summary>
            <remarks>
            IoEndpointGlobalCancelRedo errors may occur as normal operation; for this reason they are not logged as a <see cref="T:LibUsbDotNet.UsbError"/>.
            </remarks>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.GetDeviceKeyValueFailed">
            <summary>
            Failed retrieving a custom USB device key value.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.SetDeviceKeyValueFailed">
            <summary>
            Failed setting a custom USB device key value.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.Win32Error">
            <summary>
            The error is a standard windows error.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.DeviceAllreadyLocked">
            <summary>
            An attempt was made to lock a device that is already locked.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.EndpointAllreadyLocked">
            <summary>
            An attempt was made to lock an endpoint that is already locked.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.DeviceNotFound">
            <summary>
            The USB device request failed because the USB device was not found.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.UserAborted">
            <summary>
            Operation was intentionally cancelled by the user or application.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.InvalidParam">
            <summary>
            Invalid parameter.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.AccessDenied">
            <summary>
            Access denied (insufficient permissions).
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.ResourceBusy">
            <summary>
            Resource Busy.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.Overflow">
            <summary>
            Overflow.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.PipeError">
            <summary>
            Pipe error or endpoint halted.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.Interrupted">
            <summary>
            System call interrupted (perhaps due to signal).
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.InsufficientMemory">
            <summary>
            Insufficient memory.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.NotSupported">
            <summary>
            Operation not supported or unimplemented on this platform.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.UnknownError">
            <summary>
            Unknown or other error.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ErrorCode.MonoApiError">
            <summary>
            The error is one of the <see cref="T:MonoLibUsb.MonoUsbError"/>
            </summary>
        </member>
        <member name="T:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor">
            <summary>A structure representing the standard USB configuration descriptor. 
            This descriptor is documented in section 9.6.3 of the USB 2.0 specification. 
            All multiple-byte fields are represented in host-endian format.</summary>
             <example><code source="..\MonoLibUsb\MonoUsb.ShowConfig\ShowConfig.cs" lang="cs"/></example>
        </member>
        <member name="M:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.#ctor(MonoLibUsb.Profile.MonoUsbConfigHandle)">
            <summary>
            Create a new <see cref="T:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor"/> instance from a <see cref="T:MonoLibUsb.Profile.MonoUsbConfigHandle"/>.
            </summary>
            <param name="configHandle">A config handle.</param>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bLength">
            <summary> Size of this descriptor (in bytes)</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bDescriptorType">
            <summary> Descriptor type. Will have value LIBUSB_DT_CONFIG in this context.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.wTotalLength">
            <summary> Total length of data returned for this configuration</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bNumInterfaces">
            <summary> Number of interfaces supported by this configuration</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bConfigurationValue">
            <summary> Identifier value for this configuration</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.iConfiguration">
            <summary> Index of string descriptor describing this configuration</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bmAttributes">
            <summary> Configuration characteristics</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.MaxPower">
            <summary> Maximum power consumption of the USB device from this bus in this configuration when the device is fully opreation. Expressed in units of 2 mA.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.pInterfaces">
            <summary> Array of interfaces supported by this configuration. The length of this array is determined by the bNumInterfaces field.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.pExtraBytes">
            <summary> Extra descriptors. If libusb encounters unknown configuration descriptors, it will store them here, should you wish to parse them.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.ExtraLength">
            <summary> Length of the extra descriptors, in bytes.</summary>
        </member>
        <member name="P:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.ExtraBytes">
            <summary> Extra descriptors. If libusb encounters unknown configuration descriptors, it will store them here, should you wish to parse them.</summary>
        </member>
        <member name="P:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.InterfaceList">
            <summary> Array of interfaces supported by this configuration. The length of this array is determined by the bNumInterfaces field.</summary>
        </member>
        <member name="M:LibUsbDotNet.Internal.SetupApi.CM_Get_Device_ID(System.IntPtr,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="dnDevInst">Caller-supplied device instance handle that is bound to the local machine.</param>
            <param name="Buffer">Address of a buffer to receive a device instance ID string. The required buffer size can be obtained by calling CM_Get_Device_ID_Size, then incrementing the received value to allow room for the string's terminating NULL. </param>
            <param name="BufferLen">Caller-supplied length, in characters, of the buffer specified by Buffer. </param>
            <param name="ulFlags">Not used. set to 0.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in cfgmgr32.h.</returns>
        </member>
        <member name="M:LibUsbDotNet.Internal.SetupApi.CM_Get_Parent(System.IntPtr@,System.IntPtr,System.Int32)">
            <summary>
            The CM_Get_Parent function obtains a device instance handle to the parent node of a specified device node, in the local machine's device tree.
            </summary>
            <param name="pdnDevInst">Caller-supplied pointer to the device instance handle to the parent node that this function retrieves. The retrieved handle is bound to the local machine.</param>
            <param name="dnDevInst">Caller-supplied device instance handle that is bound to the local machine. </param>
            <param name="ulFlags">Not used. set to 0.</param>
            <returns>If the operation succeeds, the function returns CR_SUCCESS. Otherwise, it returns one of the CR_-prefixed error codes defined in cfgmgr32.h.</returns>
        </member>
        <member name="M:LibUsbDotNet.Internal.SetupApi.SetupDiEnumDeviceInterfaces(System.IntPtr,LibUsbDotNet.Internal.SetupApi.SP_DEVINFO_DATA@,System.Guid@,System.Int32,LibUsbDotNet.Internal.SetupApi.SP_DEVICE_INTERFACE_DATA@)">
            <summary>
            The SetupDiEnumDeviceInterfaces function enumerates the device interfaces that are contained in a device information set. 
            </summary>
            <param name="hDevInfo">A pointer to a device information set that contains the device interfaces for which to return information. This handle is typically returned by SetupDiGetClassDevs. </param>
            <param name="devInfo">A pointer to an SP_DEVINFO_DATA structure that specifies a device information element in DeviceInfoSet. This parameter is optional and can be NULL. If this parameter is specified, SetupDiEnumDeviceInterfaces constrains the enumeration to the interfaces that are supported by the specified device. If this parameter is NULL, repeated calls to SetupDiEnumDeviceInterfaces return information about the interfaces that are associated with all the device information elements in DeviceInfoSet. This pointer is typically returned by SetupDiEnumDeviceInfo. </param>
            <param name="interfaceClassGuid">A pointer to a GUID that specifies the device interface class for the requested interface. </param>
            <param name="memberIndex">A zero-based index into the list of interfaces in the device information set. The caller should call this function first with MemberIndex set to zero to obtain the first interface. Then, repeatedly increment MemberIndex and retrieve an interface until this function fails and GetLastError returns ERROR_NO_MORE_ITEMS.  If DeviceInfoData specifies a particular device, the MemberIndex is relative to only the interfaces exposed by that device.</param>
            <param name="deviceInterfaceData">A pointer to a caller-allocated buffer that contains, on successful return, a completed SP_DEVICE_INTERFACE_DATA structure that identifies an interface that meets the search parameters. The caller must set DeviceInterfaceData.cbSize to sizeof(SP_DEVICE_INTERFACE_DATA) before calling this function. </param>
            <returns></returns>
        </member>
        <member name="M:LibUsbDotNet.Internal.SetupApi.SetupDiGetClassDevs(System.Guid@,System.String,System.IntPtr,LibUsbDotNet.Internal.SetupApi.DICFG)">
            <summary>
            The SetupDiGetClassDevs function returns a handle to a device information set that contains requested device information elements for a local machine. 
            </summary>
            <param name="ClassGuid">A pointer to the GUID for a device setup class or a device interface class. This pointer is optional and can be NULL. For more information about how to set ClassGuid, see the following Comments section. </param>
            <param name="Enumerator">A pointer to a NULL-terminated string that supplies the name of a Plug and Play (PnP) enumerator or a PnP device instance identifier. This pointer is optional and can be NULL. For more information about how to set the Enumerator value, see the following Comments section. </param>
            <param name="hwndParent">A handle of the top-level window to be used for a user interface that is associated with installing a device instance in the device information set. This handle is optional and can be NULL. </param>
            <param name="Flags">A variable of type DWORD that specifies control options that filter the device information elements that are added to the device information set. This parameter can be a bitwise OR of zero or more of the following flags.</param>
            <returns></returns>
        </member>
        <member name="M:LibUsbDotNet.Internal.SetupApi.SetupDiGetDeviceInstanceId(System.IntPtr,LibUsbDotNet.Internal.SetupApi.SP_DEVINFO_DATA@,System.Text.StringBuilder,System.Int32,System.Int32@)">
            <summary>
            The SetupDiGetDeviceInstanceId function retrieves the device instance ID that is associated with a device information element.
            </summary>
            <param name="DeviceInfoSet">A handle to the device information set that contains the device information element that represents the device for which to retrieve a device instance ID. </param>
            <param name="DeviceInfoData">A pointer to an SP_DEVINFO_DATA structure that specifies the device information element in DeviceInfoSet. </param>
            <param name="DeviceInstanceId">A pointer to the character buffer that will receive the NULL-terminated device instance ID for the specified device information element. For information about device instance IDs, see Device Identification Strings.</param>
            <param name="DeviceInstanceIdSize">The size, in characters, of the DeviceInstanceId buffer. </param>
            <param name="RequiredSize">A pointer to the variable that receives the number of characters required to store the device instance ID.</param>
            <returns>The function returns TRUE if it is successful. Otherwise, it returns FALSE and the logged error can be retrieved with a call to GetLastError.</returns>
        </member>
        <member name="M:LibUsbDotNet.Internal.SetupApi.SetupDiGetDeviceRegistryProperty(System.IntPtr,LibUsbDotNet.Internal.SetupApi.SP_DEVINFO_DATA@,LibUsbDotNet.Main.SPDRP,Microsoft.Win32.RegistryValueKind@,System.Byte[],System.Int32,System.Int32@)">
            <summary>
            The SetupDiGetDeviceRegistryProperty function retrieves the specified device property.
            This handle is typically returned by the SetupDiGetClassDevs or SetupDiGetClassDevsEx function.
            </summary>
            <param Name="DeviceInfoSet">Handle to the device information set that contains the interface and its underlying device.</param>
            <param Name="DeviceInfoData">Pointer to an SP_DEVINFO_DATA structure that defines the device instance.</param>
            <param Name="Property">Device property to be retrieved. SEE MSDN</param>
            <param Name="PropertyRegDataType">Pointer to a variable that receives the registry data Type. This parameter can be NULL.</param>
            <param Name="PropertyBuffer">Pointer to a buffer that receives the requested device property.</param>
            <param Name="PropertyBufferSize">Size of the buffer, in bytes.</param>
            <param Name="RequiredSize">Pointer to a variable that receives the required buffer size, in bytes. This parameter can be NULL.</param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="F:LibUsbDotNet.Internal.SetupApi.DICFG.DEFAULT">
            <summary>
            Return only the device that is associated with the system default device interface, if one is set, for the specified device interface classes. 
             only valid with <see cref="F:LibUsbDotNet.Internal.SetupApi.DICFG.DEVICEINTERFACE"/>.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Internal.SetupApi.DICFG.PRESENT">
            <summary>
            Return only devices that are currently present in a system. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Internal.SetupApi.DICFG.ALLCLASSES">
            <summary>
            Return a list of installed devices for all device setup classes or all device interface classes. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Internal.SetupApi.DICFG.PROFILE">
            <summary>
            Return only devices that are a part of the current hardware profile. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Internal.SetupApi.DICFG.DEVICEINTERFACE">
            <summary>
            Return devices that support device interfaces for the specified device interface classes. 
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Descriptors.UsbConfigDescriptor">
            <summary> Usb Configuration Descriptor.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.Size">
            <summary>
            Total size of this structure in bytes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.TotalLength">
            <summary>
            Total length in bytes of data returned
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.InterfaceCount">
            <summary>
            Number of Interfaces
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.ConfigID">
            <summary>
            Value to use as an argument to select this Configuration
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.StringIndex">
            <summary>
            Index of String Descriptor describing this Configuration
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.Attributes">
            <summary>
            D7 Reserved, set to 1. (USB 1.0 Bus Powered)
            D6 Self Powered
            D5 Remote Wakeup
            D4..0 Reserved, set to 0.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbConfigDescriptor.MaxPower">
            <summary>
            Maximum Power Consumption in 2mA units 
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbConfigDescriptor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbConfigDescriptor"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbConfigDescriptor"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbConfigDescriptor.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbConfigDescriptor"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Descriptors.UsbConfigDescriptor"/>.</returns>
        </member>
        <member name="T:LibUsbDotNet.Main.ReadEndpointID">
            <summary> 
            Availabled endpoint numbers/ids for reading.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep01">
            <summary>
            Endpoint 1
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep02">
            <summary>
            Endpoint 2
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep03">
            <summary>
            Endpoint 3
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep04">
            <summary>
            Endpoint 4
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep05">
            <summary>
            Endpoint 5
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep06">
            <summary>
            Endpoint 6
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep07">
            <summary>
            Endpoint 7
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep08">
            <summary>
            Endpoint 8
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep09">
            <summary>
            Endpoint 9
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep10">
            <summary>
            Endpoint 10
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep11">
            <summary>
            Endpoint 11
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep12">
            <summary>
            Endpoint 12
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep13">
            <summary>
            Endpoint 13
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep14">
            <summary>
            Endpoint 14
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.ReadEndpointID.Ep15">
            <summary>
            Endpoint 15
            </summary>
        </member>
        <member name="T:MonoLibUsb.Transfer.Internal.libusb_transfer">
            <remarks>
            This class is never instantiated in .NET.  Instead it is used as a template by the <see cref="T:MonoLibUsb.Transfer.MonoUsbTransfer"/> class.
            </remarks>
        </member>
        <member name="T:MonoLibUsb.Transfer.MonoUsbTansferStatus">
            <summary>
            Transfer status codes. 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTansferStatus.TransferCompleted">
            <summary>
            Transfer completed without error. Note that this does not indicate that the entire amount of requested data was transferred.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTansferStatus.TransferError">
            <summary>
            Transfer failed 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTansferStatus.TransferTimedOut">
            <summary>
            Transfer timed out 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTansferStatus.TransferCancelled">
            <summary>
            Transfer was cancelled 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTansferStatus.TransferStall">
            <summary>
            For bulk/interrupt endpoints: halt condition detected (endpoint stalled). For control endpoints: control request not supported. 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTansferStatus.TransferNoDevice">
            <summary>
            Device was disconnected 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTansferStatus.TransferOverflow">
            <summary>
            Device sent more data than requested 
            </summary>
        </member>
        <member name="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice">
            <summary>This is the LibUsbDotNet Libusb-1.0 implementation of a <see cref="T:LibUsbDotNet.UsbDevice"/>.
            </summary> 
            <remarks>
            <para>This class is used for perform I/O and other operations on Libusb-1.0 devices using with LibUsbDotNet.</para>
            <para>This class is not a part of the low-level MonLibUsb API.  This is <see cref="T:LibUsbDotNet.UsbDevice"/> class LibUsbDotNet uses to implement the low-level MonoLibUsb API.</para>
            </remarks> 
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ResetDevice">
            <summary>
            Sends a usb device reset command.
            </summary>
            <remarks>
            After calling <see cref="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ResetDevice"/>, the <see cref="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice"/> instance is disposed and
            no longer usable.  A new <see cref="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice"/> instance must be obtained from the device list.
            </remarks>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.Close">
            <summary>
            Closes the <see cref="T:LibUsbDotNet.UsbDevice"/> and disposes any <see cref="P:LibUsbDotNet.UsbDevice.ActiveEndpoints"/>.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ControlTransfer(LibUsbDotNet.Main.UsbSetupPacket@,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Transmits control data over a default control endpoint.
            </summary>
            <param name="setupPacket">An 8-byte setup packet which contains parameters for the control request. 
            See section 9.3 USB Device Requests of the Universal Serial Bus Specification Revision 2.0 for more information. </param>
            <param name="buffer">Data to be sent/received from the device.</param>
            <param name="bufferLength">Length of the buffer param.</param>
            <param name="lengthTransferred">Number of bytes sent or received (depends on the direction of the control transfer).</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.GetDescriptor(System.Byte,System.Byte,System.Int16,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Gets a descriptor from the device. See <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> for more information.
            </summary>
            <param name="descriptorType">The descriptor type ID to retrieve; this is usually one of the <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/> enumerations.</param>
            <param name="index">Descriptor index.</param>
            <param name="langId">Descriptor language id.</param>
            <param name="buffer">Memory to store the returned descriptor in.</param>
            <param name="bufferLength">Length of the buffer parameter in bytes.</param>
            <param name="transferLength">The number of bytes transferred to buffer upon success.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.Open">
            <summary>
             Opens the USB device handle.
            </summary>
            <returns>
            True if the device is already opened or was opened successfully.
            False if the device does not exists or is no longer valid.  
            </returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.OpenEndpointReader(LibUsbDotNet.Main.ReadEndpointID,System.Int32,LibUsbDotNet.Main.EndpointType)">
            <summary>
            Opens an endpoint for reading
            </summary>
            <param name="readEndpointID">Endpoint number for read operations.</param>
            <param name="readBufferSize">Size of the read buffer allocated for the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.</param>
            <param name="endpointType">The type of endpoint to open.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class ready for reading. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointReader"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.OpenEndpointWriter(LibUsbDotNet.Main.WriteEndpointID,LibUsbDotNet.Main.EndpointType)">
            <summary>
            Opens an endpoint for writing
            </summary>
            <param name="writeEndpointID">Endpoint number for read operations.</param>
            <param name="endpointType">The type of endpoint to open.</param>
            <returns>A <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class ready for writing. If the specified endpoint is already been opened, the original <see cref="T:LibUsbDotNet.UsbEndpointWriter"/> class is returned.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.SetConfiguration(System.Byte)">
            <summary>
            Sets the USB devices active configuration value. 
            </summary>
            <param name="config">The active configuration value. A zero value means the device is not configured and a non-zero value indicates the device is configured.</param>
            <returns>True on success.</returns>
            <remarks>
            A USB device can have several different configurations, but only one active configuration.
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.GetConfiguration(System.Byte@)">
            <summary>
            Gets the USB devices active configuration value. 
            </summary>
            <param name="config">The active configuration value. A zero value means the device is not configured and a non-zero value indicates the device is configured.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ClaimInterface(System.Int32)">
            <summary>
            Claims the specified interface of the device.
            </summary>
            <param name="interfaceID">The interface to claim.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ReleaseInterface(System.Int32)">
            <summary>
            Releases an interface that was previously claimed with <see cref="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ClaimInterface(System.Int32)"/>.
            </summary>
            <param name="interfaceID">The interface to release.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.SetAltInterface(System.Int32)">
            <summary>
            Sets an alternate interface for the most recent claimed interface.
            </summary>
            <param name="alternateID">The alternate interface to select for the most recent claimed interface See <see cref="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.ClaimInterface(System.Int32)"/>.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.Init">
            <summary>
            Initializes the <see cref="P:MonoLibUsb.MonoUsbEventHandler.SessionHandle"/> with <see cref="M:MonoLibUsb.MonoUsbEventHandler.Init"/> and starts the static handle events thread with <see cref="M:MonoLibUsb.MonoUsbEventHandler.Start"/>. 
            </summary>
            <remarks>
            This is done automatically when needed.
            <para>Usually there is no need to call this functions externally.</para> 
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.MonoUsbDeviceList">
            <summary>
            Gets a <see cref="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice"/> list of Libusb-1.0 devices.  
            </summary>
            <remarks>
            <para>Using the <see cref="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.MonoUsbDeviceList"/> property will request a device list directly from the <a href="http://www.libusb.org/">Libusb-1.0</a> driver.</para> 
            <para><a href="http://www.libusb.org/">Libusb-1.0</a> is compatible with several platforms including windows.</para>
            <para>You can force LibUsbDotNet to always use <a href="http://www.libusb.org/">Libusb-1.0</a> with the <see cref="F:LibUsbDotNet.UsbDevice.ForceLibUsbWinBack"/> member.</para>
            <seealso cref="P:LibUsbDotNet.UsbDevice.AllDevices"/>
            <seealso cref="P:LibUsbDotNet.UsbDevice.AllLibUsbDevices"/>
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.DeviceAddress">
            <summary>
            Gets the instance address the device is using.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.BusNumber">
            <summary>
            Gets the bus number the device is connected to.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.DriverMode">
            <summary>
            Returns the DriverMode this USB device is using.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.Profile">
            <summary>
            Gets the <see cref="T:MonoLibUsb.Profile.MonoUsbProfile"/> for this usb device.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.UsbRegistryInfo">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class that opened the device, or null if the device was not opened by the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> class.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.Configs">
            <summary>
             Gets the available configurations for this <see cref="T:LibUsbDotNet.UsbDevice"/>
            </summary>
             <remarks>
             The first time this property is accessed it will query the <see cref="T:LibUsbDotNet.UsbDevice"/> for all configurations.  Subsequent request will return a cached copy of all configurations.
             </remarks>
        </member>
        <member name="P:LibUsbDotNet.LudnMonoLibUsb.MonoUsbDevice.Info">
            <summary>
            Gets the actual device descriptor the the current <see cref="T:LibUsbDotNet.UsbDevice"/>.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbConstants">
            <summary> Various USB constants.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.UsbConstants.DEFAULT_TIMEOUT">
            <summary>
            Default timeout for all USB IO operations.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbConstants.MAX_CONFIG_SIZE">
            <summary>
            Maximum size of a config descriptor.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbConstants.MAX_DEVICES">
            <summary>
            Maximum number of USB devices.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbConstants.MAX_ENDPOINTS">
            <summary>
            Maximum number of endpoints per device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbConstants.ENDPOINT_DIR_MASK">
            <summary>
            Endpoint direction mask.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbConstants.ENDPOINT_NUMBER_MASK">
            <summary>
            Endpoint number mask.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.EndpointDataEventArgs">
            <summary> Endpoint data received arguments returned by the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event.
            </summary> 
        </member>
        <member name="P:LibUsbDotNet.Main.EndpointDataEventArgs.Buffer">
            <summary>
            Gets the buffer of the received data.
            </summary>
            <remarks>
            Use the <see cref="P:LibUsbDotNet.Main.EndpointDataEventArgs.Count"/> property to determine the number of bytes actually received.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.EndpointDataEventArgs.Count">
            <summary>
            Gets the number of bytes received.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Transfer.MonoUsbTransfer">
            <summary>
            Reads/writes a Libusb-1.0 transfer pointer.  Transfer should be allocated with <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Alloc(System.Int32)"/>.
            </summary>
            <remarks>
            The user populates this structure and then submits it in order to request a transfer. 
            After the transfer has completed, the library populates the transfer with the results 
            and passes it back to the user.
            <note title="Libusb-1.0 API Note:" type="cpp">
            The <see cref="T:MonoLibUsb.Transfer.MonoUsbTransfer"/> structure is roughly equivalent to
            the <a href="http://libusb.sourceforge.net/api-1.0/structlibusb__transfer.html">struct libusb_transfer</a>.
            </note>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.#ctor(System.Int32)">
            <summary>
            Allocate a libusb transfer with a specified number of isochronous packet descriptors 
            </summary>
            <remarks>
            <para>The transfer is pre-initialized for you. When the new transfer is no longer needed, it should be freed with <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free"/>.</para>
            <para>Transfers intended for non-isochronous endpoints (e.g. control, bulk, interrupt) should specify an iso_packets count of zero.</para>
            <para>For transfers intended for isochronous endpoints, specify an appropriate number of packet descriptors to be allocated as part of the transfer. The returned transfer is not specially initialized for isochronous I/O; you are still required to set the <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.NumIsoPackets"/> and <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.Type"/> fields accordingly.</para>
            <para>It is safe to allocate a transfer with some isochronous packets and then use it on a non-isochronous endpoint. If you do this, ensure that at time of submission, <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.NumIsoPackets"/> is 0 and that type is set appropriately.</para>
            </remarks>
            <param name="numIsoPackets">number of isochronous packet descriptors to allocate.</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.#ctor(System.IntPtr)">
            <summary>
            Creates a new wrapper for transfers allocated by <see cref="M:MonoLibUsb.MonoUsbApi.AllocTransfer(System.Int32)"/>,
            </summary>
            <param name="pTransfer">The pointer to the transfer that was previously allocated with<see cref="M:MonoLibUsb.MonoUsbApi.AllocTransfer(System.Int32)"/>. </param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free">
             <summary>
             Frees this transfer.
             </summary>
            <remarks>
             <note title="Libusb-1.0 API Note:" type="cpp">
             <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free"/> is roughly equivalent to
             <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga6ab8b2cff4de9091298a06b2f4b86cd6">libusb_free_transfer()</a>.
             </note>
             <note type="warning">
             Calling <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free"/> on a transfer that has already been freed will result in a double free.
             </note> 
             </remarks>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.UniqueName">
            <summary>
            Gets a unqiue name for this transfer.
            </summary>
            <returns>A unqiue name for this transfer.</returns>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.IsoPacket(System.Int32)">
            <summary>
            Gets a <see cref="T:MonoLibUsb.Transfer.MonoUsbIsoPacket"/> that represents the specified iso packet descriptor. 
            </summary>
            <param name="packetNumber">The iso packet descriptor to return.</param>
            <returns>The <see cref="T:MonoLibUsb.Transfer.MonoUsbIsoPacket"/> that represents <paramref name="packetNumber"/>.</returns>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.Cancel">
            <summary>
            Cancels this transfer.
            </summary>
            <remarks>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Cancel"/> is roughly equivalent to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga685eb7731f9a0593f75beb99727bbe54">libusb_cancel_transfer()</a>.
            </note>
            </remarks>
            <returns><see cref="F:MonoLibUsb.MonoUsbError.Success"/> if the cancel succeeds, otherwise one of the other <see cref="T:MonoLibUsb.MonoUsbError"/> codes.</returns>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillBulk(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Delegate,System.IntPtr,System.Int32)">
            <summary>
            Helper function to populate the required <see cref="T:MonoLibUsb.Transfer.MonoUsbTransfer"/> properties for a bulk transfer.
            </summary>
            <remarks>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillBulk(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Delegate,System.IntPtr,System.Int32)"/> is similar to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#gad4ddb1a5c6c7fefc979a44d7300b95d7">libusb_fill_bulk_transfer()</a>.
            </note>
            </remarks>
            <param name="devHandle">handle of the device that will handle the transfer</param>
            <param name="endpoint">address of the endpoint where this transfer will be sent</param>
            <param name="buffer">data buffer</param>
            <param name="length">length of data buffer</param>
            <param name="callback">callback function to be invoked on transfer completion</param>
            <param name="userData">user data to pass to callback function</param>
            <param name="timeout">timeout for the transfer in milliseconds</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillInterrupt(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Delegate,System.IntPtr,System.Int32)">
            <summary>
            Helper function to populate the required <see cref="T:MonoLibUsb.Transfer.MonoUsbTransfer"/> properties for an interrupt transfer.
            </summary>
            <remarks>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillInterrupt(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Delegate,System.IntPtr,System.Int32)"/> is roughly equivalent to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga90f53cea1124a7566df1aa1202b77510">libusb_fill_interrupt_transfer()</a>.
            </note>
            </remarks>
            <param name="devHandle">handle of the device that will handle the transfer</param>
            <param name="endpoint">address of the endpoint where this transfer will be sent</param>
            <param name="buffer">data buffer</param>
            <param name="length">length of data buffer</param>
            <param name="callback">callback function to be invoked on transfer completion</param>
            <param name="userData">user data to pass to callback function</param>
            <param name="timeout">timeout for the transfer in milliseconds</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillIsochronous(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Int32,System.Delegate,System.IntPtr,System.Int32)">
            <summary>
            Helper function to populate the required <see cref="T:MonoLibUsb.Transfer.MonoUsbTransfer"/> properties for an isochronous transfer.
            </summary>
            <remarks>
            <note type="tip">
            <para>Isochronous transfers are not supported on windows.</para>
            </note>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillIsochronous(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Int32,System.Delegate,System.IntPtr,System.Int32)"/> is similar to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga30fdce8c461e851f0aa4c851014e1aa7">libusb_fill_iso_transfer()</a>.
            </note>
            </remarks>
            <param name="devHandle">handle of the device that will handle the transfer</param>
            <param name="endpoint">address of the endpoint where this transfer will be sent</param>
            <param name="buffer">data buffer</param>
            <param name="length">length of data buffer</param>
            <param name="numIsoPackets">the number of isochronous packets</param>
            <param name="callback">callback function to be invoked on transfer completion</param>
            <param name="userData">user data to pass to callback function</param>
            <param name="timeout">timeout for the transfer in milliseconds</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.GetIsoPacketBuffer(System.Int32)">
            <summary>
            Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer. 
            </summary>
            <remarks>
            <para>This is a thorough function which loops through all preceding packets, accumulating their lengths to find the position of the specified packet. Typically you will assign equal lengths to each packet in the transfer, and hence the above method is sub-optimal. You may wish to use <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.GetIsoPacketBufferSimple(System.Int32)"/> instead.</para>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.GetIsoPacketBuffer(System.Int32)"/> is roughly equivalent to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga7f6ea0eb35a216d19d984977e454a7b3">libusb_get_iso_packet_buffer()</a>.
            </note>
            </remarks>
            <param name="packet">The packet to return the address of.</param>
            <returns>the base address of the packet buffer inside the transfer buffer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the packet requested is &gt;= <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.NumIsoPackets"/>.</exception>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.GetIsoPacketBufferSimple(System.Int32)">
            <summary>
            Convenience function to locate the position of an isochronous packet within the buffer of an isochronous transfer, for transfers where each packet is of identical size.
            </summary>
            <remarks>
            <para>This function relies on the assumption that every packet within the transfer is of identical size to the first packet. Calculating the location of the packet buffer is then just a simple calculation: buffer + (packet_size * packet)</para>
            <para>Do not use this function on transfers other than those that have identical packet lengths for each packet.</para>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.GetIsoPacketBufferSimple(System.Int32)"/> is roughly equivalent to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga3df9a28c4f5c8f1850181ddb5efd12fd">libusb_get_iso_packet_buffer_simple()</a>.
            </note>        
            </remarks>
            <param name="packet">The packet to return the address of.</param>
            <returns>the base address of the packet buffer inside the transfer buffer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">This exception is thrown if the packet requested is &gt;= <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.NumIsoPackets"/>.</exception>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.SetIsoPacketLengths(System.Int32)">
            <summary>
            Convenience function to set the length of all packets in an isochronous transfer, based on the num_iso_packets field in the transfer structure. 
            </summary>
            <remarks>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.SetIsoPacketLengths(System.Int32)"/> is roughly equivalent to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#gacbdecd6f50093f0c1d0e72ee35ace274">libusb_set_iso_packet_lengths()</a>.
            </note>   
            </remarks>
            <param name="length">The length to set in each isochronous packet descriptor.</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.Submit">
            <summary>
            Submits this transfer.
            </summary>
            <remarks>
            This functions submits the USB transfer and return immediately.
            <note>
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Submit"/> is roughly equivalent to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#gabb0932601f2c7dad2fee4b27962848ce">libusb_submit_transfer()</a>.
            </note>
            </remarks>
            <returns>
            <see cref="F:MonoLibUsb.MonoUsbError.Success"/> if the submit succeeds, 
            otherwise one of the other <see cref="T:MonoLibUsb.MonoUsbError"/> codes.
            </returns>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.Alloc(System.Int32)">
            <summary>
            Allocate a libusb transfer with a specified number of isochronous packet descriptors 
            </summary>
            <remarks>
            <para>The returned transfer is pre-initialized for you. When the new transfer is no longer needed, it should be freed with <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free"/>.</para>
            <para>Transfers intended for non-isochronous endpoints (e.g. control, bulk, interrupt) should specify an iso_packets count of zero.</para>
            <para>For transfers intended for isochronous endpoints, specify an appropriate number of packet descriptors to be allocated as part of the transfer. The returned transfer is not specially initialized for isochronous I/O; you are still required to set the <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.NumIsoPackets"/> and <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.Type"/> fields accordingly.</para>
            <para>It is safe to allocate a transfer with some isochronous packets and then use it on a non-isochronous endpoint. If you do this, ensure that at time of submission, <see cref="P:MonoLibUsb.Transfer.MonoUsbTransfer.NumIsoPackets"/> is 0 and that type is set appropriately.</para>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Alloc(System.Int32)"/> is roughly equivalent to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga13cc69ea40c702181c430c950121c000">libusb_alloc_transfer()</a>.
            </note>
            </remarks>
            <param name="numIsoPackets">number of isochronous packet descriptors to allocate.</param>
            <returns>A newly allocated <see cref="T:MonoLibUsb.Transfer.MonoUsbTransfer"/>.</returns>
            <exception cref="T:System.OutOfMemoryException">If the transfer was not allocated.</exception>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillControl(MonoLibUsb.MonoUsbDeviceHandle,MonoLibUsb.Transfer.MonoUsbControlSetupHandle,System.Delegate,System.IntPtr,System.Int32)">
            <summary>
            Helper function to populate the required <see cref="T:MonoLibUsb.Transfer.MonoUsbTransfer"/> properties for a control transfer.
            </summary>
            <remarks>
            <note type="tip">
            <para>Isochronous transfers are not supported on windows.</para>
            </note>
            <note title="Libusb-1.0 API Note:" type="cpp">
            <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.FillControl(MonoLibUsb.MonoUsbDeviceHandle,MonoLibUsb.Transfer.MonoUsbControlSetupHandle,System.Delegate,System.IntPtr,System.Int32)"/> is similar to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga3a8513ed87229fe2c9771ef0bf17206e">libusb_fill_control_transfer()</a>.
            </note>
            </remarks>
            <param name="devHandle">handle of the device that will handle the transfer</param>
            <param name="controlSetupHandle">the setup packet/control data to transfer.</param>
            <param name="callback">callback function to be invoked on transfer completion</param>
            <param name="userData">user data to pass to callback function</param>
            <param name="timeout">timeout for the transfer in milliseconds</param>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.PtrBuffer">
            <summary>
            Gets the buffer data pointer.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.PtrUserData">
            <summary>
            User context data to pass to the callback function.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.PtrCallbackFn">
            <summary>
            Callback function pointer.
            </summary>
            <remarks>
            The callback function must be declared as a <see cref="T:MonoLibUsb.MonoUsbTransferDelegate"/>.
            </remarks>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.ActualLength">
            <summary>
            Actual length of data that was transferred. 
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.Length">
            <summary>
            Length of the data buffer.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.Status">
            <summary>
            The status of the transfer.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.Timeout">
            <summary>
            Timeout for this transfer in millseconds.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.Type">
            <summary>
            Type of the endpoint. 
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.Endpoint">
            <summary>
            Enpoint address.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.Flags">
            <summary>
            A bitwise OR combination of <see cref="T:MonoLibUsb.Transfer.MonoUsbTransferFlags"/>.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.PtrDeviceHandle">
            <summary>
            Raw device handle pointer.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.NumIsoPackets">
            <summary>
            Number of isochronous packets. 
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbTransfer.IsInvalid">
            <summary>
            True if the transfer is allocated.
            </summary>
        </member>
        <member name="T:MonoLibUsb.MonoUsbEventHandler">
            <summary>
            Manages a static Libusb-1.0 <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> and "handle_events" thread for simplified asynchronous IO.
            </summary>
            <remarks>
            <para>This class contains its own <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> that is initialized with one of the overloaded <see cref="M:MonoLibUsb.MonoUsbEventHandler.Init">MonoUsbEventHandler.Init()</see> functions.</para>
            <para>This class contains a static thread that execute <see cref="M:MonoLibUsb.MonoUsbApi.HandleEventsTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)"/>. See the <see cref="M:MonoLibUsb.MonoUsbEventHandler.Start"/> and <see cref="M:MonoLibUsb.MonoUsbEventHandler.Stop(System.Boolean)"/> methods.</para>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.MonoUsbEventHandler.Exit">
            <summary>
            Stops the handle events thread and closes the session handle.
            </summary>
        </member>
        <member name="M:MonoLibUsb.MonoUsbEventHandler.Init(System.Int64,System.Int64)">
            <summary>
            Initializes the <see cref="P:MonoLibUsb.MonoUsbEventHandler.SessionHandle"/> and sets a custom polling interval.
            </summary>
            <param name="tvSec">polling interval seconds</param>
            <param name="tvUsec">polling interval milliseconds</param>
            <seealso cref="M:MonoLibUsb.MonoUsbEventHandler.Init"/>
            <seealso cref="P:MonoLibUsb.MonoUsbEventHandler.SessionHandle"/> 
        </member>
        <member name="M:MonoLibUsb.MonoUsbEventHandler.Init">
            <summary>
            Initializes the <see cref="P:MonoLibUsb.MonoUsbEventHandler.SessionHandle"/>.
            </summary>
            <remarks>
            <para>If the session has already been initialized, this method does nothing.</para>
            <para>The handle events thread is not started until the <see cref="M:MonoLibUsb.MonoUsbEventHandler.Start"/> method is called.</para>
            <para>Uses the MonoLibUsb <see cref="P:MonoLibUsb.UnixNativeTimeval.Default"/> polling interval for <see cref="M:MonoLibUsb.MonoUsbApi.HandleEventsTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)"/>.</para>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.MonoUsbEventHandler.Start">
            <summary>
            Starts the handle events thread.
            </summary>
            <remarks>
            <para>If the thread is already running, this method does nothing.</para>
            <para>
            Using a seperate thread which executes <see cref="M:MonoLibUsb.MonoUsbApi.HandleEventsTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)"/> can simplify asynchronous I/O
            and improve performance in multi-threaded applications which use multiple endpoints.
            </para>
            </remarks>
            <returns>
            True if the thread is started or is already running.
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbEventHandler.Stop(System.Boolean)">
            <summary>
            Stops the handle events thread.
            </summary>
            <remarks>
            <para>Calling this method when the thread is not running will have no affect.</para>
            <note type="warning">
            If the thread is running, this method must be called before the application exits.
            Failure to do so will cause the application to hang.
            </note>
            </remarks>
            <param name="bWait">If true, wait for the thread to exit before returning.</param>
        </member>
        <member name="P:MonoLibUsb.MonoUsbEventHandler.SessionHandle">
            <summary>
            Gets the session handle. 
            </summary>
            <remarks>
            Used for MonoLibUsb members that require the <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> parameter.
            </remarks>
        </member>
        <member name="P:MonoLibUsb.MonoUsbEventHandler.IsStopped">
            <summary>
            False if the handle events thread is running.
            </summary>
        </member>
        <member name="P:MonoLibUsb.MonoUsbEventHandler.Priority">
            <summary>
            Thread proirity to use for the handle events thread.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.DataReceivedEnabledChangedEventArgs">
            <summary>
            Event arguments that are passed when <see cref="P:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabled"/> is changes state.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.DataReceivedEnabledChangedEventArgs.ErrorCode">
            <summary>
            The <see cref="T:LibUsbDotNet.Main.ErrorCode"/> that caused the <see cref="E:LibUsbDotNet.UsbEndpointReader.DataReceived"/> event to terminate.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.DataReceivedEnabledChangedEventArgs.Enabled">
            <summary>
            <c>True</c> if <see cref="P:LibUsbDotNet.UsbEndpointReader.DataReceivedEnabled"/> changes from <c>True</c> to <c>False</c>. 
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo">
            <summary> Common inteface describing USB DEVICE INTERFACE arrival and removal events.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.SymbolicName">
            <summary>
            The symbolc name class for this device.  For more information, see <see cref="T:LibUsbDotNet.Main.UsbSymbolicName"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.Name">
            <summary>
            Gets the full name of the USB device that caused the notification.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.ClassGuid">
            <summary>
            Gets the Class Guid of the USB device that caused the notification.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.IdVendor">
            <summary>
            Parses and returns the VID from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.IdProduct">
            <summary>
            Parses and returns the PID from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.SerialNumber">
            <summary>
            Parses and returns the serial number from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbDeviceFinder">
            <summary>
            Finds and identifies usb devices. Used for easily locating  
            </summary>
            <remarks>
            <list type="bullet">
            <item>
            Instances of this class can optionally be passed directly into 
            <see cref="M:LibUsbDotNet.UsbDevice.OpenUsbDevice(LibUsbDotNet.Main.UsbDeviceFinder)"/> 
            to quickly find and open a specific usb device in one step.
            </item>
            <item>
            Pass instances of this class into the 
            <see cref="M:LibUsbDotNet.Main.UsbRegDeviceList.Find(LibUsbDotNet.Main.UsbDeviceFinder)"/>, 
            <see cref="M:LibUsbDotNet.Main.UsbRegDeviceList.FindAll(LibUsbDotNet.Main.UsbDeviceFinder)"/>,  
            or <see cref="M:LibUsbDotNet.Main.UsbRegDeviceList.FindLast(LibUsbDotNet.Main.UsbDeviceFinder)"/> 
            functions of a  <see cref="T:LibUsbDotNet.Main.UsbRegDeviceList"/> 
            instance to find connected usb devices without opening devices or interrogating the bus.
            After locating the required <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> instance, call the 
            <see cref="M:LibUsbDotNet.Main.UsbRegistry.Open(LibUsbDotNet.UsbDevice@)"/> method to start using the <see cref="T:LibUsbDotNet.UsbDevice"/> instance.
            </item>
            </list>
            </remarks>
            <example>
            <code source="..\Examples\Show.Info\ShowInfo.cs" lang="cs"/>
            </example>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbDeviceFinder.NO_PID">
            <summary> The "exclude from search" value for <see cref="P:LibUsbDotNet.Main.UsbDeviceFinder.Pid"/>. </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbDeviceFinder.NO_REV">
            <summary> The "exclude from search" value for <see cref="P:LibUsbDotNet.Main.UsbDeviceFinder.Revision"/>. </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbDeviceFinder.NO_SERIAL">
            <summary> The "exclude from search" value for <see cref="P:LibUsbDotNet.Main.UsbDeviceFinder.SerialNumber"/>. </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbDeviceFinder.NO_VID">
            <summary> The "exclude from search" value for <see cref="P:LibUsbDotNet.Main.UsbDeviceFinder.Vid"/>. </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbDeviceFinder.NO_GUID">
            <summary>  The "exclude from search" value for <see cref="P:LibUsbDotNet.Main.UsbDeviceFinder.DeviceInterfaceGuid"/>. </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.Int32,System.Int32,System.Int32,System.String,System.Guid)">
            <summary>
            Creates a UsbDeviceFinder class for locating and identifying usb devices.
            </summary>
            <param name="vid">The vendor id of the usb device to find, or <see cref="F:System.Int32.MaxValue"/> to ignore.</param>
            <param name="pid">The product id of the usb device to find, or <see cref="F:System.Int32.MaxValue"/> to ignore.</param>
            <param name="revision">The revision number of the usb device to find, or <see cref="F:System.Int32.MaxValue"/> to ignore.</param>
            <param name="serialNumber">The serial number of the usb device to find, or null to ignore.</param>
            <param name="deviceInterfaceGuid">The unique guid of the usb device to find, or <see cref="F:System.Guid.Empty"/> to ignore.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Creates a UsbDeviceFinder class for locating usb devices by VendorID, ProductID, and Serial number.
            </summary>
            <param name="vid">The vendor id of the usb device to find.</param>
            <param name="pid">The product id of the usb device to find.</param>
            <param name="serialNumber">The serial number of the usb device to find.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a UsbDeviceFinder class for locating usb devices by VendorID, ProuctID, and Revision code.
            </summary>
            <param name="vid">The vendor id of the usb device to find.</param>
            <param name="pid">The product id of the usb device to find.</param>
            <param name="revision">The revision number of the usb device to find.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a UsbDeviceFinder class for locating usb devices vendor and product ID.
            </summary>
            <param name="vid">The vendor id of the usb device to find.</param>
            <param name="pid">The product id of the usb device to find.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.Int32)">
            <summary>
            Creates a UsbDeviceFinder class for locating usb devices.
            </summary>
            <param name="vid">The vendor id of the usb device to find.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.String)">
            <summary>
            Creates a UsbDeviceFinder class for locating usb devices by a serial number.
            </summary>
            <param name="serialNumber">The serial number of the usb device to find.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.Guid)">
            <summary>
            Creates a UsbDeviceFinder class for locating usb devices by a unique <see cref="T:System.Guid"/> string.
            </summary>
            <param name="deviceInterfaceGuid">The unique <see cref="T:System.Guid"/> to find.</param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Use a serialization stream to fill the <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> class. 
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Store this class as a binary serializtion object.
            </summary>
            <param name="info">The serialization instance to populate.</param>
            <param name="context"></param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.Load(System.IO.Stream)">
            <summary>
            Load usb device finder properties from a binary stream.
            </summary>
            <param name="deviceFinderStream">The binary stream containing a
            <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> </param> instance.
            <returns>A pre-loaded <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.Save(LibUsbDotNet.Main.UsbDeviceFinder,System.IO.Stream)">
            <summary>
            Saves a <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> instance to a stream.
            </summary>
            <param name="usbDeviceFinder"></param>
            <param name="outStream"></param>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.Check(LibUsbDotNet.Main.UsbRegistry)">
            <summary>
            Dynamic predicate find function. Pass this function into any method that has a <see cref="T:System.Predicate`1"/> parameter.
            </summary>
            <remarks>
            Override this member when inheriting the <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> class to change/alter the matching behavior.
            </remarks>
            <param name="usbRegistry">The UsbRegistry device to check.</param>
            <returns>True if the <see cref="T:LibUsbDotNet.Main.UsbRegistry"/> instance matches the <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> properties.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbDeviceFinder.Check(LibUsbDotNet.UsbDevice)">
            <summary>
            Dynamic predicate find function. Pass this function into any method that has a <see cref="T:System.Predicate`1"/> parameter.
            </summary>
            <remarks>
            Override this member when inheriting the <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> class to change/alter the matching behavior.
            </remarks>
            <param name="usbDevice">The UsbDevice to check.</param>
            <returns>True if the <see cref="T:LibUsbDotNet.UsbDevice"/> instance matches the <see cref="T:LibUsbDotNet.Main.UsbDeviceFinder"/> properties.</returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbDeviceFinder.DeviceInterfaceGuid">
            <summary>
            The device interface guid string to find, or <see cref="F:System.String.Empty"/> to ignore.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbDeviceFinder.SerialNumber">
            <summary>
            The serial number of the device to find.
            </summary>
            <remarks>
            Set to null to ignore.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbDeviceFinder.Revision">
            <summary>
            The revision number of the device to find.
            </summary>
            <remarks>
            Set to <see cref="F:System.Int32.MaxValue"/> to ignore.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbDeviceFinder.Pid">
            <summary>
            The product id of the device to find.
            </summary>
            <remarks>
            Set to <see cref="F:System.Int32.MaxValue"/> to ignore.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbDeviceFinder.Vid">
            <summary>
            The vendor id of the device to find.
            </summary>
            <remarks>
            Set to <see cref="F:System.Int32.MaxValue"/> to ignore.
            </remarks>
        </member>
        <member name="T:LibUsbDotNet.Internal.UsbRegex.RegSymbolicName">
            <summary>
            Regular expression class for parsing USB symbolic names and hardware ids.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Internal.WinUsb.SafeWinUsbInterfaceHandle.ReleaseHandle">
            <summary>
            Executes the code required to free the <see cref="T:LibUsbDotNet.Internal.WinUsb.SafeWinUsbInterfaceHandle"/>.
            </summary>
            
            <returns>
            true if the <see cref="T:LibUsbDotNet.Internal.WinUsb.SafeWinUsbInterfaceHandle"/> is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a ReleaseHandleFailed Managed Debugging Assistant.
            </returns>
            
        </member>
        <member name="P:LibUsbDotNet.Internal.WinUsb.SafeWinUsbInterfaceHandle.IsInvalid">
            <summary>
            Gets a value indicating whether the <see cref="T:LibUsbDotNet.Internal.WinUsb.SafeWinUsbInterfaceHandle"/> value is invalid.
            </summary>
            
            <returns>
            true if the <see cref="T:LibUsbDotNet.Internal.WinUsb.SafeWinUsbInterfaceHandle"/> is valid; otherwise, false.
            </returns>
        </member>
        <member name="T:LibUsbDotNet.Info.UsbDeviceInfo">
            <summary> Contains USB device descriptor information.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.Info.UsbDeviceInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Info.UsbDeviceInfo.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Info.UsbInterfaceInfo"/>.</returns>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbDeviceInfo.Descriptor">
            <summary>
            The raw <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/> for the current <see cref="T:LibUsbDotNet.UsbDevice"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbDeviceInfo.CurrentCultureLangID">
            <summary>
            Request all available languages from the USB device (string index 0) and return the most appropriate LCID given the current operating systems locale settings. See System.Globalization.CultureInfo.CurrentCulture.LCID.
            </summary>
            <remarks>
            Once the USB devices CurrentCultureLangID has been retreived, subsequent request will return a cached copy of the LCID.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbDeviceInfo.ManufacturerString">
            <summary>
            Gets the string representation of the <see cref="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ManufacturerStringIndex"/> string index.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbDeviceInfo.ProductString">
            <summary>
            Gets the string representation of the <see cref="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ProductStringIndex"/> string index.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbDeviceInfo.SerialString">
            <summary>
            Gets the string representation of the <see cref="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.SerialStringIndex"/> string index.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Profile.MonoUsbProfileHandle">
            <summary>
            Wraps a profile handle into a <see cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject"/>. 
            Profile handles are used for getting device descriptor information and opening the device.  Profile handles
            are known connected and usually supported usb device that can be opened and used.
            </summary>
            <remarks>
            <para>
            When a <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> instance is created and wrapped around the 
            <a href="http://libusb.sourceforge.net/api-1.0/group__dev.html#ga77eedd00d01eb7569b880e861a971c2b">libusb_device</a>
            pointer, <see cref="M:MonoLibUsb.MonoUsbApi.RefDevice(System.IntPtr)"/> is called.  When all references to this 
            <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> instance are out-of-scope or have all been closed, this profile handle is de-referenced with 
            <see cref="M:MonoLibUsb.MonoUsbApi.UnrefDevice(System.IntPtr)"/>.
            When the reference count equals zero, memory is freed and resources are released.
            </para>
            <para>
            The <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> class ensures all device profiles get closed and freed 
            regardless of abnormal program terminations or coding errors. 
            </para>
            <para>
            Certain operations can be performed using just the <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/>, but in order to do 
            any I/O you will have to first obtain a <see cref="T:MonoLibUsb.MonoUsbDeviceHandle"/> using <see cref="M:MonoLibUsb.MonoUsbApi.Open(MonoLibUsb.Profile.MonoUsbProfileHandle,System.IntPtr@)"/>.
            </para>
            </remarks>    
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileHandle.#ctor(System.IntPtr)">
            <summary>
            Wraps a raw usb device profile handle pointer in a <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> class.
            </summary>
            <param name="pProfileHandle">the profile handle to wrap.</param>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileHandle.ReleaseHandle">
            <summary>
            When overridden in a derived class, executes the code required to free the handle.
            </summary>
            <returns>
            true if the handle is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a ReleaseHandleFailed Managed Debugging Assistant.
            </returns>
        </member>
        <member name="T:MonoLibUsb.Profile.MonoUsbConfigHandle">
            <summary>
            The <see cref="T:MonoLibUsb.Profile.MonoUsbConfigHandle"/> class hold the internal pointer to a libusb <see cref="T:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor"/>.
            </summary>
            <remarks>
            <para>
            To acquire a <see cref="T:MonoLibUsb.Profile.MonoUsbConfigHandle"/> use:
            <list type="bullet">
            <item><see cref="M:MonoLibUsb.MonoUsbApi.GetActiveConfigDescriptor(MonoLibUsb.Profile.MonoUsbProfileHandle,MonoLibUsb.Profile.MonoUsbConfigHandle@)"/></item>
            <item><see cref="M:MonoLibUsb.MonoUsbApi.GetConfigDescriptor(MonoLibUsb.Profile.MonoUsbProfileHandle,System.Byte,MonoLibUsb.Profile.MonoUsbConfigHandle@)"/></item>
            <item><see cref="M:MonoLibUsb.MonoUsbApi.GetConfigDescriptorByValue(MonoLibUsb.Profile.MonoUsbProfileHandle,System.Byte,MonoLibUsb.Profile.MonoUsbConfigHandle@)"/></item>
            </list>
            </para>
            <para>To access configuration information see <see cref="M:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.#ctor(MonoLibUsb.Profile.MonoUsbConfigHandle)"/>.</para>
            <example><code source="..\MonoLibUsb\MonoUsb.ShowConfig\ShowConfig.cs" lang="cs"/></example>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbConfigHandle.ReleaseHandle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor">
            <summary>A structure representing the standard USB device descriptor. 
            This descriptor is documented in section 9.6.1 of the USB 2.0 specification. 
            All multiple-byte fields are represented in host-endian format.</summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.Size">
            <summary>
            Total size of this structure in bytes.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.Length">
            <summary>
            Length of structure reported by the associated usb device.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.DescriptorType">
            <summary>
            Type of structure reported by the associated usb device.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.BcdUsb">
            <summary>
            USB Specification Number which device complies too.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.Class">
            <summary>
            Class Code (Assigned by USB Org)
            If equal to Zero, each interface specifies it’s own class code; If equal to 0xFF, the class code is vendor specified; Otherwise field is valid Class Code.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.SubClass">
            <summary>
            Subclass Code (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.Protocol">
            <summary>
            Protocol Code (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.MaxPacketSize0">
            <summary>
            Maximum Packet Size for Zero Endpoint. Valid Sizes are 8, 16, 32, 64
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.VendorID">
            <summary>
            Vendor ID (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.ProductID">
            <summary>
            Product ID (Assigned by Manufacturer)
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.BcdDevice">
            <summary>
            Device Release Number
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.ManufacturerStringIndex">
            <summary>
            Index of Manufacturer String Descriptor
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.ProductStringIndex">
            <summary>
            Index of Product String Descriptor
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.SerialStringIndex">
            <summary>
            Index of Serial Number String Descriptor
            </summary>
        </member>
        <member name="F:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.ConfigurationCount">
            <summary>
            Number of Possible Configurations
            </summary>
        </member>
        <member name="M:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor"/>.
            </returns>
        </member>
        <member name="T:LibUsbDotNet.Main.WriteEndpointID">
            <summary> Availabled endpoint numbers/ids for writing.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep01">
            <summary>
            Endpoint 1
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep02">
            <summary>
            Endpoint 2
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep03">
            <summary>
            Endpoint 3
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep04">
            <summary>
            Endpoint 4
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep05">
            <summary>
            Endpoint 5
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep06">
            <summary>
            Endpoint 6
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep07">
            <summary>
            Endpoint 7
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep08">
            <summary>
            Endpoint 8
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep09">
            <summary>
            Endpoint 9
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep10">
            <summary>
            Endpoint 10
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep11">
            <summary>
            Endpoint 11
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep12">
            <summary>
            Endpoint 12
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep13">
            <summary>
            Endpoint 13
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep14">
            <summary>
            Endpoint 14
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.WriteEndpointID.Ep15">
            <summary>
            Endpoint 15
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbSymbolicName">
            <summary> USB device symbolic names are persistent accrossed boots and uniquely identify each device.
            </summary> 
            <remarks> As well as uniquely identify connected devices, the UsbSymbolicName class parses the symbolic name key into usable fields.
            </remarks> 
        </member>
        <member name="M:LibUsbDotNet.Main.UsbSymbolicName.Parse(System.String)">
            <summary>
            Parses registry strings containing USB information.  This function can Parse symbolic names as well as hardware ids, compatible ids, etc.
            </summary>
            <param name="identifiers"></param>
            <returns>A <see cref="T:LibUsbDotNet.Main.UsbSymbolicName"/> class with all the available information from the <paramref name="identifiers"/> string.</returns>
            <remarks>
            <code>
                        List&lt;UsbRegistryDeviceInfo&gt; regDeviceList = UsbGlobals.RegFindDevices();
               foreach (UsbRegistryDeviceInfo regDevice in mDevList)
               {
                   string[] hardwareIds = (string[])regDevice.Properties[DevicePropertyType.HardwareID];
                  UsbSymbolicName usbHardwareID = UsbSymbolicName.Parse(hardwareIds[0]);
                   Debug.Print(string.Format("Vid:0x{0:X4} Pid:0x{1:X4}", usbHardwareID.Vid, usbHardwareID.Pid));
               }
            </code>
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbSymbolicName.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Main.UsbSymbolicName"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Main.UsbSymbolicName"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbSymbolicName.FullName">
            <summary>
            The full symbolic name of the device.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbSymbolicName.Vid">
            <summary>
            VendorId parsed out of the <see cref="P:LibUsbDotNet.Main.UsbSymbolicName.FullName"/>
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbSymbolicName.Pid">
            <summary>
            ProductId parsed out of the <see cref="P:LibUsbDotNet.Main.UsbSymbolicName.FullName"/>
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbSymbolicName.SerialNumber">
            <summary>
            SerialNumber parsed out of the <see cref="P:LibUsbDotNet.Main.UsbSymbolicName.FullName"/>
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbSymbolicName.ClassGuid">
            <summary>
            Device class parsed out of the <see cref="P:LibUsbDotNet.Main.UsbSymbolicName.FullName"/>
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbSymbolicName.Rev">
            <summary>
            Usb device revision number.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.LibUsb.LibUsbRegistry">
            <summary> LibUsb specific members for device registry settings.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbRegistry.Open(LibUsbDotNet.LibUsb.LibUsbDevice@)">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <param name="usbDevice">The newly created UsbDevice.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LibUsb.LibUsbRegistry.Open(LibUsbDotNet.UsbDevice@)">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <param name="usbDevice">The newly created UsbDevice.</param>
            <returns>True on success.</returns>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbRegistry.DeviceIndex">
            <summary>
            Gets the 0 based index of this libusb device
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbRegistry.DeviceList">
            <summary>
            Gets a list of available LibUsb devices.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbRegistry.IsAlive">
            <summary>
            Check this value to determine if the usb device is still connected to the bus and ready to open.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbRegistry.Device">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <returns>Return a new instance of the <see cref="T:LibUsbDotNet.UsbDevice"/> class.
            If the device fails to open a null refrence is return. For extended error
            information use the <see cref="E:LibUsbDotNet.UsbDevice.UsbErrorEvent"/>.
             </returns>
        </member>
        <member name="P:LibUsbDotNet.LibUsb.LibUsbRegistry.DeviceInterfaceGuids">
            <summary>
            Gets the DeviceInterfaceGuids for the WinUsb device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbStatusClodes.ErrorIoPending">
            <summary>
            Returned bo overlapped IO functions when data is still pending.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Transfer.Internal.libusb_iso_packet_descriptor">
            <remarks>
            This class is never instantiated in .NET.  Instead it is used as a template by the <see cref="T:MonoLibUsb.Transfer.MonoUsbIsoPacket"/> class.
            </remarks>
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_iso_packet_descriptor.length">
            <summary>
            Length of data to request in this packet 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_iso_packet_descriptor.actual_length">
            <summary>
            Amount of data that was actually transferred 
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.Internal.libusb_iso_packet_descriptor.status">
            <summary>
            Status code for this packet 
            </summary>
        </member>
        <member name="T:MonoLibUsb.MonoUsbTransferDelegate">
            <summary>
            Asynchronous transfer callback delegate
            </summary>
            <param name="transfer">The transfer previously allocated with <see cref="M:MonoLibUsb.MonoUsbApi.AllocTransfer(System.Int32)"/>.</param>
        </member>
        <member name="T:MonoLibUsb.PollfdAddedDelegate">
            <summary>
            Callback delegate, invoked when a new file descriptor should be added to the set of file descriptors monitored for events. 
            </summary>
            <param name="fd">The new file descriptor.</param>
            <param name="events">Events to monitor for, see PollfdItem for a description.</param>
            <param name="user_data">User data pointer specified in <see cref="M:MonoLibUsb.MonoUsbApi.SetPollfdNotifiers(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.PollfdAddedDelegate,MonoLibUsb.PollfdRemovedDelegate,System.IntPtr)"/> call.</param>
        </member>
        <member name="T:MonoLibUsb.PollfdRemovedDelegate">
            <summary>
            Callback delegate, invoked when a file descriptor should be removed from the set of file descriptors being monitored for events.
            </summary>
            <remarks>After returning from this callback, do not use that file descriptor again. </remarks>
            <param name="fd">The file descriptor to stop monitoring.</param>
            <param name="user_data">User data pointer specified in <see cref="M:MonoLibUsb.MonoUsbApi.SetPollfdNotifiers(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.PollfdAddedDelegate,MonoLibUsb.PollfdRemovedDelegate,System.IntPtr)"/> call.</param>
        </member>
        <member name="T:LibUsbDotNet.LibUsb.LibUsbKernelType">
            <summary>
            Kernel types supported by LibUsbDotNet.  See <see cref="P:LibUsbDotNet.UsbDevice.KernelType"/> for more details.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.LibUsb.LibUsbKernelType.Unknown">
            <summary>
            LibUsb support us unavailable.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.LibUsb.LibUsbKernelType.NativeLibUsb">
            <summary>
            LibUsbDotNet native kernel driver detected.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.LibUsb.LibUsbKernelType.LegacyLibUsb">
            <summary>
            Original libusb-win32 kernel driver detected.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.LibUsb.LibUsbKernelType.MonoLibUsb">
            <summary>
            mono-linux libusb 1.x driver detected.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor">
            <summary> Usb Device Descriptor
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.Size">
            <summary>
            Total size of this structure in bytes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.BcdUsb">
            <summary>
            USB Specification Number which device complies too.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.Class">
            <summary>
            Class Code (Assigned by USB Org)
            If equal to Zero, each interface specifies it’s own class code; If equal to 0xFF, the class code is vendor specified; Otherwise field is valid Class Code.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.SubClass">
            <summary>
            Subclass Code (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.Protocol">
            <summary>
            Protocol Code (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.MaxPacketSize0">
            <summary>
            Maximum Packet Size for Zero Endpoint. Valid Sizes are 8, 16, 32, 64
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.VendorID">
            <summary>
            Vendor ID (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ProductID">
            <summary>
            Product ID (Assigned by Manufacturer)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.BcdDevice">
            <summary>
            Device Release Number
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ManufacturerStringIndex">
            <summary>
            Index of Manufacturer String Descriptor
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ProductStringIndex">
            <summary>
            Index of Product String Descriptor
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.SerialStringIndex">
            <summary>
            Index of Serial Number String Descriptor
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ConfigurationCount">
            <summary>
            Number of Possible Configurations
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>.</returns>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.Equals(LibUsbDotNet.Descriptors.UsbDeviceDescriptor)">
            <summary>
            Determines whether the specified <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/> is equal to the current <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/> is equal to the current <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>; otherwise, false.
            </returns>
            <param name="other">The <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/> to compare with the current <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="other"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.op_Equality(LibUsbDotNet.Descriptors.UsbDeviceDescriptor,LibUsbDotNet.Descriptors.UsbDeviceDescriptor)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbDeviceDescriptor.op_Inequality(LibUsbDotNet.Descriptors.UsbDeviceDescriptor,LibUsbDotNet.Descriptors.UsbDeviceDescriptor)">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbTransferQueue">
            <summary>
            Helper class for maintaining a user defined number of outstanding aync transfers on an endpoint.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransferQueue.#ctor(LibUsbDotNet.Main.UsbEndpointBase,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new transfer queue instance.
            </summary>
            <param name="endpointBase">The endpoint to transfer data to/from.</param>
            <param name="maxOutstandingIO">The number of transfers to <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/> before waiting for a completion.</param>
            <param name="bufferSize">The size of each data buffer.</param>
            <param name="timeout">The maximum time to wait for each transfer.</param>
            <param name="isoPacketSize">For isochronous use only.  The iso packet size.  If 0, the endpoints max packet size is used.</param>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.EndpointBase">
            <summary>
            Endpoint for I/O operations.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.MaxOutstandingIO">
            <summary>
            Maximum outstanding I/O operations before waiting for a completion.
            This is also the number of data buffers allocated for this transfer queue.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.BufferSize">
            <summary>
            Size (in bytes) of each data buffer in this transfer queue.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.Timeout">
            <summary>
            Time (in milliseconds) to wait for a transfer to complete before returning <see cref="F:LibUsbDotNet.Main.ErrorCode.IoTimedOut"/>.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.IsoPacketSize">
            <summary>
            For isochronous use only.  The iso packet size.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransferQueue.Transfer(LibUsbDotNet.Main.UsbTransferQueue.Handle@)">
            <summary>
            Submits transfers until <see cref="F:LibUsbDotNet.Main.UsbTransferQueue.MaxOutstandingIO"/> is reached then waits for the oldest transfer to complete.  
            </summary>
            <param name="handle">The queue handle to the <see cref="T:LibUsbDotNet.Main.UsbTransfer"/> that completed.</param>
            <returns><see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if data was transferred, or another <see cref="T:LibUsbDotNet.Main.ErrorCode"/> on error.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbTransferQueue.Free">
            <summary>
            Cancels and frees all oustanding transfers.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransferQueue.Item(System.Int32)">
            <summary>
            Gets the transfer data buffer at the specified index.
            </summary>
            <param name="index">The index of the buffer to retrieve.</param>
            <returns>The byte array for a transfer.</returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbTransferQueue.Buffer">
            <summary>
            Gets a two dimensional array of data buffers. The first index represents the transfer the second represents the data buffer.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbTransferQueue.Handle">
            <summary>
            A transfer queue handle.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.Handle.Context">
            <summary>
            Transfer context.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.Handle.Data">
            <summary>
            Data buffer.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbTransferQueue.Handle.Transferred">
            <summary>
            Number of bytes sent/received.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifyEventArgs">
            <summary>
            Describes the device notify event
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.WinUsb.DeviceSpeedTypes">
            <summary> Device speed types
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.WinUsb.DeviceSpeedTypes.Undefined">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:LibUsbDotNet.WinUsb.DeviceSpeedTypes.LowSpeed">
            <summary>
            Low speed device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.WinUsb.DeviceSpeedTypes.FullSpeed">
            <summary>
            Full speed device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.WinUsb.DeviceSpeedTypes.HighSpeed">
            <summary>
            High speed device.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointWriter">
            <summary>
            Implements mono-linux libusb 1.x methods for writing to methods for writing data to a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> or <see cref="F:LibUsbDotNet.Main.EndpointType.Interrupt"/> endpoints.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointWriter.Dispose">
            <summary>
            Frees resources associated with the endpoint.  Once disposed this class cannot be used.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointWriter.Flush">
            <summary>
            This method has no effect on write endpoints, andalways returs true.
            </summary>
            <returns>True</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointWriter.Reset">
            <summary>
            Cancels pending transfers and clears the halt condition on an enpoint.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="T:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointReader">
            <summary>
            Implements mono-linux libusb 1.x methods for reading data from a <see cref="F:LibUsbDotNet.Main.EndpointType.Bulk"/> or <see cref="F:LibUsbDotNet.Main.EndpointType.Interrupt"/> endpoints.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointReader.Dispose">
            <summary>
            Frees resources associated with the endpoint.  Once disposed this class cannot be used.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointReader.Flush">
            <summary>
            Calling this methods is that same as calling <see cref="M:LibUsbDotNet.UsbEndpointReader.ReadFlush"/>
            </summary>
            <returns>True an success.</returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.MonoUsbEndpointReader.Reset">
            <summary>
            Cancels pending transfers and clears the halt condition on an enpoint.
            </summary>
            <returns>True on success.</returns>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo">
            <summary> Notify information for a communication port
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Info.IPortNotifyInfo">
            <summary> Common interface describing a communication port arrival or removal notification.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Info.IPortNotifyInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.IPortNotifyInfo.Name">
            <summary>
            Under windows, Gets the name of the port that caused the event.
            Under windows, Gets the full path of the device caused the event.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.PortNotifyInfo.Name">
            <summary>
            Gets the name of the port that caused the event.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.DeviceNotifier">
            <summary>
            Platform independent class for linux/windows device notification.
            </summary>
            <code source="..\Examples\Device.Notification\DeviceNotification.cs" lang="cs"/>
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.DeviceNotifier.OpenDeviceNotifier">
            <summary>
            Creates a new instance of a device notifier class.
            </summary>
            <returns>A <see cref="T:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifier"/> under windows and a <see cref="T:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifier"/> under linux.</returns>
        </member>
        <member name="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor">
            <summary> Usb Interface Descriptor.
            </summary> 
            <remarks> This is the actual descriptor as described in the USB 2.0 Specifications.
            </remarks> 
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.Size">
            <summary>
            Total size of this structure in bytes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.InterfaceID">
            <summary>
            Number of Interface
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.AlternateID">
            <summary>
            Value used to select alternative setting
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.EndpointCount">
            <summary>
            Number of Endpoints used for this interface
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.Class">
            <summary>
            Class Code (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.SubClass">
            <summary>
            Subclass Code (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.Protocol">
            <summary>
            Protocol Code (Assigned by USB Org)
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.StringIndex">
            <summary>
            Index of String Descriptor Describing this interface
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Descriptors.UsbInterfaceDescriptor"/>.</returns>
        </member>
        <member name="T:MonoLibUsb.Transfer.MonoUsbControlSetupHandle">
            <summary>
            Allocates memory and fills an asynchronous control setup packet. 
            </summary>
            <remarks>
            <note type="tip">This type is used for asynchronous control transfers only.</note>
            </remarks>
            <seealso cref="T:MonoLibUsb.Transfer.MonoUsbControlSetup"/>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbControlSetupHandle.#ctor(System.Byte,System.Byte,System.Int16,System.Int16,System.Object,System.Int32)">
            <summary>
            Allocates memory and sets up a control setup packet. Copies control data into the control data buffer
            </summary>
            <remarks>
            <para>This constructor is used when <paramref name="requestType"/> has the <see cref="F:LibUsbDotNet.Main.UsbCtrlFlags.Direction_In"/> flag and this request will contain control data (more than just the setup packet).</para>
            <para>Allocates <see cref="F:MonoLibUsb.Transfer.MonoUsbControlSetup.SETUP_PACKET_SIZE"/> + <paramref name="data"/>.Length for the setup packet. The setup packet is stored first then the control data.</para>
            <para>The <paramref name="data"/> array is copied into the setup packet starting at <see cref="F:MonoLibUsb.Transfer.MonoUsbControlSetup.SETUP_PACKET_SIZE"/>.</para>
            <note title="Libusb-1.0 API Note:" type="cpp">
            This contructor is similar to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup()</a>.
            </note>
            </remarks>
            <param name="requestType">The request type field for the setup packet.</param>
            <param name="request">The request field for the setup packet.</param>
            <param name="value">The value field for the setup packet</param>
            <param name="index">The index field for the setup packet.</param>
            <param name="data">The control data buffer to copy into the setup packet.</param>
            <param name="length">Size of <paramref name="data"/> in bytes.  This value is also used for the wLength field of the setup packet.</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbControlSetupHandle.#ctor(System.Byte,System.Byte,System.Int16,System.Int16,System.Int16)">
            <summary>
            Allocates memory and sets up a control setup packet.
            </summary>
            <remarks>
            <para>This constructor is used when:
            <list type="bullet">
            <item><paramref name="requestType"/> has the <see cref="F:LibUsbDotNet.Main.UsbCtrlFlags.Direction_In"/> flag and this request will not contain extra data (just the setup packet).</item>
            <item><paramref name="requestType"/> does not have the <see cref="F:LibUsbDotNet.Main.UsbCtrlFlags.Direction_In"/> flag.</item>
            </list>
            </para>
            <note title="Libusb-1.0 API Note:" type="cpp">
            This contructor is similar to
            <a href="http://libusb.sourceforge.net/api-1.0/group__asyncio.html#ga5447311149ec2bd954b5f1a640a8e231">libusb_fill_control_setup()</a>.
            </note>
            <para>Allocates <see cref="F:MonoLibUsb.Transfer.MonoUsbControlSetup.SETUP_PACKET_SIZE"/> + <paramref name="length"/> for the setup packet. The setup packet is stored first then the control data.</para>
            </remarks>
            <param name="requestType">The request type field for the setup packet.</param>
            <param name="request">The request field for the setup packet.</param>
            <param name="value">The value field for the setup packet</param>
            <param name="index">The index field for the setup packet.</param>
            <param name="length">The length to allocate for the data portion of the setup packet.</param>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbControlSetupHandle.ReleaseHandle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbControlSetupHandle.ControlSetup">
            <summary>
            Returns the <see cref="T:MonoLibUsb.Transfer.MonoUsbControlSetup"/> for this handle.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.WinUsb.PipeInformation">
            <summary> WinUsb Pipe information.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.WinUsb.PipeInformation.Size">
            <summary>
            Size of the structure in bytes.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.WinUsb.PipeInformation.PipeType">
            <summary>
            Specifies the pipe type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.WinUsb.PipeInformation.PipeId">
            <summary>
            The pipe identifier (ID). 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.WinUsb.PipeInformation.MaximumPacketSize">
            <summary>
            The maximum size, in bytes, of the packets that are transmitted on the pipe.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.WinUsb.PipeInformation.Interval">
            <summary>
            The pipe interval.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Internal.UsbRegex.RegHardwareID">
            <summary>
            Regular expression class for quick parsing of usb hardware ids.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.WinUsb.WinUsbRegistry">
            <summary> WinUsb specific members for device registry settings.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbRegistry.GetDevicePathList(System.Guid,System.Collections.Generic.List{System.String}@)">
            <summary>
            Gets a list of WinUSB device paths for the specified interface guid.
            </summary>
            <param name="deviceInterfaceGuid">The DeviceInterfaceGUID to search for.</param>
            <param name="devicePathList">A list of device paths associated with the <paramref name="deviceInterfaceGuid"/>.</param>
            <returns>True of one or more device paths was found.</returns>
            <remarks>
            Each device path string in the <paramref name="devicePathList"/> represents a seperate WinUSB device (interface).
            </remarks>
            <seealso cref="M:LibUsbDotNet.WinUsb.WinUsbRegistry.GetWinUsbRegistryList(System.Guid,System.Collections.Generic.List{LibUsbDotNet.WinUsb.WinUsbRegistry}@)"/>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbRegistry.GetWinUsbRegistryList(System.Guid,System.Collections.Generic.List{LibUsbDotNet.WinUsb.WinUsbRegistry}@)">
            <summary>
            Gets a list of <see cref="T:LibUsbDotNet.WinUsb.WinUsbRegistry"/> classes for the specified interface guid.
            </summary>
            <param name="deviceInterfaceGuid">The DeviceInterfaceGUID to search for.</param>
            <param name="deviceRegistryList">A list of device paths associated with the <paramref name="deviceInterfaceGuid"/>.</param>
            <returns>True of one or more device paths was found.</returns>
            <remarks>
            Each <see cref="T:LibUsbDotNet.WinUsb.WinUsbRegistry"/> in the <paramref name="deviceRegistryList"/> represents a seperate WinUSB device (interface).
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbRegistry.Open(LibUsbDotNet.UsbDevice@)">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <param name="usbDevice">The newly created UsbDevice.</param>
            <returns>True on success.</returns>
        </member>
        <member name="M:LibUsbDotNet.WinUsb.WinUsbRegistry.Open(LibUsbDotNet.WinUsb.WinUsbDevice@)">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <param name="usbDevice">Returns an opened WinUsb device on success, null on failure.</param>
            <returns>True on success.</returns>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.DeviceList">
            <summary>
            Gets a list of available LibUsb devices.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.DeviceInterfaceGuids">
            <summary>
            Gets a collection of DeviceInterfaceGuids that are associated with this WinUSB device.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.IsAlive">
            <summary>
            Check this value to determine if the usb device is still connected to the bus and ready to open.
            </summary>
            <remarks>
            Uses the symbolic name as a unique id to determine if this device instance is still attached.
            </remarks>
            <exception cref="T:LibUsbDotNet.Main.UsbException">An exception is thrown if the <see cref="P:LibUsbDotNet.Main.UsbRegistry.SymbolicName"/> property is null or empty.</exception>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.Device">
            <summary>
            Opens the USB device for communucation.
            </summary>
            <returns>Return a new instance of the <see cref="T:LibUsbDotNet.UsbDevice"/> class.
            If the device fails to open a null refrence is return. For extended error
            information use the <see cref="E:LibUsbDotNet.UsbDevice.UsbErrorEvent"/>.
             </returns>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.DeviceID">
            <summary>
            Gets the device instance id.
            </summary>
            <remarks>
            For more information on device instance ids, see the <a href="http://msdn.microsoft.com/en-us/library/ff538405%28v=VS.85%29.aspx">CM_Get_Device_ID Function</a> at MSDN.
            </remarks>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.Vid">
            <summary>
            VendorID
            </summary>
            <remarks>This value is parsed out of the <see cref="P:LibUsbDotNet.WinUsb.WinUsbRegistry.DeviceID"/> field.</remarks>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.Pid">
            <summary>
            ProductID
            </summary>
            <remarks>This value is parsed out of the <see cref="P:LibUsbDotNet.WinUsb.WinUsbRegistry.DeviceID"/> field.</remarks>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.WinUsbRegistry.InterfaceID">
            <summary>
             Gets the interface ID this WinUSB device (interface) is associated with.
            </summary>
             <remarks>This value is parsed out of the <see cref="P:LibUsbDotNet.WinUsb.WinUsbRegistry.DeviceID"/> field.</remarks>
        </member>
        <member name="T:LibUsbDotNet.WinUsb.PowerPolicies">
            <summary> 
            power policy for a <see cref="T:LibUsbDotNet.WinUsb.WinUsbDevice"/>.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.WinUsb.PowerPolicies.Finalize">
            <summary>
            Frees instance resources.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PowerPolicies.AutoSuspend">
            <summary>
            If the auto suspend policy parameter is TRUE (that is, nonzero), the USB stack suspends the device when no transfers are pending. The default value for the AutoSuspend policy parameter is TRUE.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.WinUsb.PowerPolicies.SuspendDelay">
            <summary>
            The suspend delay policy parameter specifies the minimum amount of time, in milliseconds, that the WinUSB driver must wait after any transfer before it can suspend the device. 
            </summary>
        </member>
        <member name="T:MonoLibUsb.MonoUsbApi">
            <summary>
            Libusb-1.0 low-level API library.
            </summary>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.SetDebug(MonoLibUsb.MonoUsbSessionHandle,System.Int32)">
            <summary>Set message verbosity.</summary>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="level">Debug level to set.</param>
            <remarks>
            <list type="bullet">
            <item>Level 0: no messages ever printed by the library. (default)</item>
            <item>Level 1: error messages are printed to stderr.</item>
            <item>Level 2: warning and error messages are printed to stderr.</item>
            <item>Level 3: informational messages are printed to stdout, warning and error messages are printed to stderr</item>
            </list>
            <para>The default level is 0, which means no messages are ever printed. If you choose to increase the message verbosity level, ensure that your application does not close the stdout/stderr file descriptors.</para>
            <para>You are advised to set level 3. libusb is conservative with its message logging and most of the time, will only log messages that explain error conditions and other oddities. This will help you debug your software.</para>
            <para>If the LIBUSB_DEBUG environment variable was set when libusb was initialized, this function does nothing: the message verbosity is fixed to the value in the environment variable.</para>
            <para>If libusb was compiled without any message logging, this function does nothing: you'll never get any messages.</para>
            <para>If libusb was compiled with verbose debug message logging, this function does nothing: you'll always get messages from all levels.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="lib"/></note>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetDeviceList(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.Profile.MonoUsbProfileListHandle@)">
            <summary>
            Returns a list of USB devices currently attached to the system. 
            </summary>
            <remarks>
            <para>This is your entry point into finding a USB device to operate.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="monoUSBProfileListHandle">	output location for a list of devices.</param>
            <returns>The number of devices in the outputted list, or <see cref="F:MonoLibUsb.MonoUsbError.ErrorNoMem"/> on memory allocation failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetBusNumber(MonoLibUsb.Profile.MonoUsbProfileHandle)">
            <summary>
            Get the number of the bus that a device is connected to. 
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <returns>The bus number.</returns>
            <param name="deviceProfileHandle">A device profile handle.</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetDeviceAddress(MonoLibUsb.Profile.MonoUsbProfileHandle)">
            <summary>
            Get the address of the device on the bus it is connected to. 
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <returns>The device address.</returns>
            <param name="deviceProfileHandle">A device profile handle.</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetMaxPacketSize(MonoLibUsb.Profile.MonoUsbProfileHandle,System.Byte)">
            <summary>
            Convenience function to retrieve the wMaxPacketSize value for a particular endpoint in the active device configuration. 
            </summary>
            <param name="deviceProfileHandle">A device profile handle.</param>
            <param name="endpoint">Endpoint address to retrieve the max packet size for.</param>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            <para>This function was originally intended to be of assistance when setting up isochronous transfers, but a design mistake resulted in this function instead. It simply returns the <see cref="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.wMaxPacketSize"/> value without considering its contents. If you're dealing with isochronous transfers, you probably want <see cref="M:MonoLibUsb.MonoUsbApi.GetMaxIsoPacketSize(MonoLibUsb.Profile.MonoUsbProfileHandle,System.Byte)"/> instead.</para>
            </remarks>
            <returns>The <see cref="F:MonoLibUsb.Descriptors.MonoUsbEndpointDescriptor.wMaxPacketSize"/></returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetMaxIsoPacketSize(MonoLibUsb.Profile.MonoUsbProfileHandle,System.Byte)">
            <summary>
            Calculate the maximum packet size which a specific endpoint is capable is sending or receiving in the duration of 1 microframe.
            </summary>
            <remarks>
            <para>Only the active configuration is examined. The calculation is based on the wMaxPacketSize field in the endpoint descriptor as described in section 9.6.6 in the USB 2.0 specifications.</para>
            <para>If acting on an isochronous or interrupt endpoint, this function will multiply the value found in bits 0:10 by the number of transactions per microframe (determined by bits 11:12). Otherwise, this function just returns the numeric value found in bits 0:10.</para>
            <para>This function is useful for setting up isochronous transfers, for example you might pass the return value from this function to <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.SetIsoPacketLengths(System.Int32)">libusb_set_iso_packet_lengths</see> in order to set the length field of every isochronous packet in a transfer.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceProfileHandle">A device profile handle.</param>
            <param name="endpoint">Endpoint address to retrieve the max packet size for.</param>
            <returns>The maximum packet size which can be sent/received on this endpoint.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.OpenDeviceWithVidPid(MonoLibUsb.MonoUsbSessionHandle,System.Int16,System.Int16)">
            <summary>
            Convenience function for finding a device with a particular idVendor/idProduct combination. 
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="vendorID">The idVendor value to search for.</param>
            <param name="productID">The idProduct value to search for.</param>
            <returns>Null if the device was not opened or not found, otherwise an opened device handle.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetDevice(MonoLibUsb.MonoUsbDeviceHandle)">
            <summary>
            Get a <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> for a <see cref="T:MonoLibUsb.MonoUsbDeviceHandle"/>. 
            </summary>
            <remarks>
            <para>
            This function differs from the Libusb-1.0 C API in that when the new <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> is returned, the device profile reference count 
            is incremented ensuring the profile will remain valid as long as it is in-use.
            </para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="devicehandle">A device handle.</param>
            <returns>The underlying profile handle.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetConfiguration(MonoLibUsb.MonoUsbDeviceHandle,System.Int32@)">
            <summary>
            Determine the <see cref="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bConfigurationValue"/> of the currently active configuration. 
            </summary>
            <remarks>
            <para>You could formulate your own control request to obtain this information, but this function has the advantage that it may be able to retrieve the information from operating system caches (no I/O involved).</para>
            <para>If the OS does not cache this information, then this function will block while a control transfer is submitted to retrieve the information.</para>
            <para>This function will return a value of 0 in the <paramref name="configuration"/> parameter if the device is in unconfigured state.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="configuration">Output location for the <see cref="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bConfigurationValue"/> of the active configuration. (only valid for return code 0)</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.SetConfiguration(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)">
            <summary>
            Set the active configuration for a device. 
            </summary>
            <remarks>
            <para>The operating system may or may not have already set an active configuration on the device. It is up to your application to ensure the correct configuration is selected before you attempt to claim interfaces and perform other operations.</para>
            <para>If you call this function on a device already configured with the selected configuration, then this function will act as a lightweight device reset: it will issue a SET_CONFIGURATION request using the current configuration, causing most USB-related device state to be reset (altsetting reset to zero, endpoint halts cleared, toggles reset).</para>
            <para>You cannot change/reset configuration if your application has claimed interfaces - you should free them with <see cref="M:MonoLibUsb.MonoUsbApi.ReleaseInterface(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)"/> first. You cannot change/reset configuration if other applications or drivers have claimed interfaces.</para>
            <para>A configuration value of -1 will put the device in unconfigured state. The USB specifications state that a configuration value of 0 does this, however buggy devices exist which actually have a configuration 0.</para>
            <para>You should always use this function rather than formulating your own SET_CONFIGURATION control request. This is because the underlying operating system needs to know when such changes happen.</para>
            <para>This is a blocking function.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="configuration">The <see cref="F:MonoLibUsb.Descriptors.MonoUsbConfigDescriptor.bConfigurationValue"/> of the configuration you wish to activate, or -1 if you wish to put the device in unconfigured state </param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the requested configuration does not exist</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorBusy"/> if interfaces are currently claimed</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.ClaimInterface(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)">
            <summary>
            Claim an interface on a given device handle. 
            </summary>
            <remarks>
            <para>You must claim the interface you wish to use before you can perform I/O on any of its endpoints.</para>
            <para>It is legal to attempt to claim an already-claimed interface, in which case libusb just returns 0 without doing anything.</para>
            <para>Claiming of interfaces is a purely logical operation; it does not cause any requests to be sent over the bus. Interface claiming is used to instruct the underlying operating system that your application wishes to take ownership of the interface.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="interfaceNumber">the <see cref="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bInterfaceNumber"/> of the interface you wish to claim.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the requested interface does not exist</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorBusy"/> if another program or driver has claimed the interface </item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.ReleaseInterface(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)">
            <summary>
            Release an interface previously claimed with <see cref="M:MonoLibUsb.MonoUsbApi.ClaimInterface(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)"/>.
            </summary>
            <remarks>
            <para>You should release all claimed interfaces before closing a device handle.</para>
            <para>This is a blocking function. A SET_INTERFACE control request will be sent to the device, resetting interface state to the first alternate setting.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="interfaceNumber">the <see cref="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bInterfaceNumber"/> of the interface you wish to claim.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the interface was not claimed</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.SetInterfaceAltSetting(MonoLibUsb.MonoUsbDeviceHandle,System.Int32,System.Int32)">
            <summary>
            Activate an alternate setting for an interface.
            </summary>
            <remarks>
            <para>The interface must have been previously claimed with <see cref="M:MonoLibUsb.MonoUsbApi.ClaimInterface(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)"/>.</para>
            <para>You should always use this function rather than formulating your own SET_INTERFACE control request. This is because the underlying operating system needs to know when such changes happen.</para>
            <para>This is a blocking function.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="interfaceNumber">The <see cref="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bInterfaceNumber"/> of the previously-claimed interface.</param>
            <param name="alternateSetting">The <see cref="F:MonoLibUsb.Descriptors.MonoUsbAltInterfaceDescriptor.bAlternateSetting"/> of the alternate setting to activate.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the interface was not claimed, or the requested alternate setting does not exist</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.ClearHalt(MonoLibUsb.MonoUsbDeviceHandle,System.Byte)">
            <summary>
            Clear the halt/stall condition for an endpoint.
            </summary>
            <remarks>
            <para>Endpoints with halt status are unable to receive or transmit data until the halt condition is stalled.</para>
            <para>You should cancel all pending transfers before attempting to clear the halt condition.</para>
            <para>This is a blocking function.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="endpoint">The endpoint to clear halt status.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the endpoint does not exist</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.ResetDevice(MonoLibUsb.MonoUsbDeviceHandle)">
            <summary>
            Perform a USB port reset to reinitialize a device. 
            </summary>
            <remarks>
            <para>The system will attempt to restore the previous configuration and alternate settings after the reset has completed.</para>
            <para>If the reset fails, the descriptors change, or the previous state cannot be restored, the device will appear to be disconnected and reconnected. This means that the device handle is no longer valid (you should close it) and rediscover the device. A return code of <see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> indicates when this is the case.</para>
            <para>This is a blocking function which usually incurs a noticeable delay.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if re-enumeration is required, or if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.KernelDriverActive(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)">
            <summary>
            Determine if a kernel driver is active on an interface. 
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="interfaceNumber">The interface to check.</param>
            <returns>
            <list type="bullet">
            <item>0 if no kernel driver is active.</item>
            <item>1 if a kernel driver is active.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected.</item>
            <item>Another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure.</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.DetachKernelDriver(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)">
            <summary>
            Detach a kernel driver from an interface.
            </summary>
            <remarks>
            <para>If successful, you will then be able to claim the interface and perform I/O.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="interfaceNumber">The interface to detach the driver from.</param>
            <returns>
            <list type="bullet">
            <item>0 on success.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if no kernel driver was active.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorInvalidParam"/> if the interface does not exist.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected </item>
            <item>Another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure.</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.AttachKernelDriver(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)">
            <summary>
            Re-attach an interface's kernel driver, which was previously detached using <see cref="M:MonoLibUsb.MonoUsbApi.DetachKernelDriver(MonoLibUsb.MonoUsbDeviceHandle,System.Int32)"/>.
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="dev"/></note>
            </remarks>
            <param name="deviceHandle">A device handle.</param>
            <param name="interfaceNumber">The interface to attach the driver from.</param>
            <returns>
            <list type="bullet">
            <item>0 on success.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if no kernel driver was active.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorInvalidParam"/> if the interface does not exist.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorBusy"/> if the driver cannot be attached because the interface is claimed by a program or driver.</item>
            <item>Another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure.</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetDeviceDescriptor(MonoLibUsb.Profile.MonoUsbProfileHandle,MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor)">
            <summary>
            Gets the standard device descriptor.
            </summary>
            <remarks>
            <note type="tip">This is a non-blocking function which does not involve any requests being sent to the device.</note>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="desc"/></note>
            </remarks>
            <param name="deviceProfileHandle">A device profile handle.</param>
            <param name="deviceDescriptor">The <see cref="T:MonoLibUsb.Descriptors.MonoUsbDeviceDescriptor"/> clas that will hold the data.</param>
            <returns>0 on success or a <see cref="T:MonoLibUsb.MonoUsbError"/> code on failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetActiveConfigDescriptor(MonoLibUsb.Profile.MonoUsbProfileHandle,MonoLibUsb.Profile.MonoUsbConfigHandle@)">
            <summary>
            Get the USB configuration descriptor for the currently active configuration.
            </summary>
            <remarks>
            <note type="tip">This is a non-blocking function which does not involve any requests being sent to the device.</note>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="desc"/></note>
            </remarks>
            <param name="deviceProfileHandle">A device profile handle.</param>
            <param name="configHandle">A config handle.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the device is in unconfigured state </item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on error</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetConfigDescriptor(MonoLibUsb.Profile.MonoUsbProfileHandle,System.Byte,MonoLibUsb.Profile.MonoUsbConfigHandle@)">
            <summary>
            Get a USB configuration descriptor based on its index. 
            </summary>
            <remarks>
            <note type="tip">This is a non-blocking function which does not involve any requests being sent to the device.</note>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="desc"/></note>
            </remarks>
            <param name="deviceProfileHandle">A device profile handle.</param>
            <param name="configIndex">The index of the configuration you wish to retrieve.</param>
            <param name="configHandle">A config handle.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the device is in unconfigured state </item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on error</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetConfigDescriptorByValue(MonoLibUsb.Profile.MonoUsbProfileHandle,System.Byte,MonoLibUsb.Profile.MonoUsbConfigHandle@)">
            <summary>
            Get a USB configuration descriptor with a specific bConfigurationValue.
            </summary>
            <remarks>
            <note type="tip">This is a non-blocking function which does not involve any requests being sent to the device.</note>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="desc"/></note>
            </remarks>
            <param name="deviceProfileHandle">A device profile handle.</param>
            <param name="bConfigurationValue">The bConfigurationValue of the configuration you wish to retrieve.</param>
            <param name="configHandle">A config handle.</param>
            <returns>
            <list type="bullet">
            <item>0 on success</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNotFound"/> if the device is in unconfigured state </item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on error</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetDescriptor(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.Byte,System.IntPtr,System.Int32)">
            <summary>
            Retrieve a descriptor from the default control pipe. 
            </summary>
            <remarks>
            <para>This is a convenience function which formulates the appropriate control message to retrieve the descriptor.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="desc"/></note>
            </remarks>
            <param name="deviceHandle">Retrieve a descriptor from the default control pipe.</param>
            <param name="descType">The descriptor type, <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/></param>
            <param name="descIndex">The index of the descriptor to retrieve.</param>
            <param name="pData">Output buffer for descriptor.</param>
            <param name="length">Size of data buffer.</param>
            <returns>Number of bytes returned in data, or a <see cref="T:MonoLibUsb.MonoUsbError"/> code on failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetDescriptor(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.Byte,System.Object,System.Int32)">
            <summary>
            Retrieve a descriptor from the default control pipe. 
            </summary>
            <remarks>
            <para>This is a convenience function which formulates the appropriate control message to retrieve the descriptor.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="desc"/></note>
            </remarks>
            <param name="deviceHandle">Retrieve a descriptor from the default control pipe.</param>
            <param name="descType">The descriptor type, <see cref="T:LibUsbDotNet.Descriptors.DescriptorType"/></param>
            <param name="descIndex">The index of the descriptor to retrieve.</param>
            <param name="data">Output buffer for descriptor. This object is pinned using <see cref="T:LibUsbDotNet.Main.PinnedHandle"/>.</param>
            <param name="length">Size of data buffer.</param>
            <returns>Number of bytes returned in data, or <see cref="T:MonoLibUsb.MonoUsbError"/> code on failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.TryLockEvents(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Attempt to acquire the event handling lock.
            </summary>
            <remarks>
            <para>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.</para>
            <para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb's file descriptors directly. If you stick to libusb's event handling loop functions (e.g. <see cref="M:MonoLibUsb.MonoUsbApi.HandleEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_handle_events</see>) then you do not need to be concerned with this locking.</para>
            <para>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <see cref="M:MonoLibUsb.MonoUsbApi.UnlockEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_unlock_events</see> as soon as possible.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <returns>
            <list type="bullet">
            <item>0 if the lock was obtained successfully.</item>
            <item>1 if the lock was not obtained. (i.e. another thread holds the lock)</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.LockEvents(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Acquire the event handling lock, blocking until successful acquisition if it is contended. 
            </summary>
            <remarks>
            <para>This lock is used to ensure that only one thread is monitoring libusb event sources at any one time.</para>
            <para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb's file descriptors directly. If you stick to libusb's event handling loop functions (e.g. <see cref="M:MonoLibUsb.MonoUsbApi.HandleEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_handle_events</see>) then you do not need to be concerned with this locking.</para>
            <para>While holding this lock, you are trusted to actually be handling events. If you are no longer handling events, you must call <see cref="M:MonoLibUsb.MonoUsbApi.UnlockEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_unlock_events</see> as soon as possible.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.UnlockEvents(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Release the lock previously acquired with <see cref="M:MonoLibUsb.MonoUsbApi.TryLockEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_try_lock_events</see> or <see cref="M:MonoLibUsb.MonoUsbApi.LockEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_lock_events</see>. 
            </summary>
            <remarks>
            <para>Releasing this lock will wake up any threads blocked on <see cref="M:MonoLibUsb.MonoUsbApi.WaitForEvent(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_wait_for_event</see>.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.EventHandlingOk(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Determine if it is still OK for this thread to be doing event handling. 
            </summary>
            <remarks>
            <para>Sometimes, libusb needs to temporarily pause all event handlers, and this is the function you should use before polling file descriptors to see if this is the case.</para>
            <para>If this function instructs your thread to give up the events lock, you should just continue the usual logic that is documented in Multi-threaded applications and asynchronous I/O. On the next iteration, your thread will fail to obtain the events lock, and will hence become an event waiter.</para>
            <para>This function should be called while the events lock is held: you don't need to worry about the results of this function if your thread is not the current event handler.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <returns>
            <list type="bullet">
            <item>1 if event handling can start or continue.</item>
            <item>0 if this thread must give up the events lock.</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.EventHandlerActive(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Determine if an active thread is handling events (i.e. if anyone is holding the event handling lock).
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <returns>
            <list type="bullet">
            <item>1 if a thread is handling events.</item>
            <item>0 if there are no threads currently handling events.</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.LockEventWaiters(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Acquire the event waiters lock.
            </summary>
            <remarks>
            <para>This lock is designed to be obtained under the situation where you want to be aware when events are completed, but some other thread is event handling so calling <see cref="M:MonoLibUsb.MonoUsbApi.HandleEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_handle_events</see> is not allowed.</para>
            <para>You then obtain this lock, re-check that another thread is still handling events, then call <see cref="M:MonoLibUsb.MonoUsbApi.WaitForEvent(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_wait_for_event</see>.</para>
            <para>You only need to use this lock if you are developing an application which calls poll() or select() on libusb's file descriptors directly, and may potentially be handling events from 2 threads simultaenously. If you stick to libusb's event handling loop functions (e.g. <see cref="M:MonoLibUsb.MonoUsbApi.HandleEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_handle_events</see>) then you do not need to be concerned with this locking.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.UnlockEventWaiters(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Release the event waiters lock. 
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.WaitForEvent(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">
            <summary>
            Wait for another thread to signal completion of an event. 
            </summary>
            <remarks>
            <para>
            This function will block until any of the following conditions are met:
            <list type="numbered">
            <item>The timeout expires.</item>
            <item>A transfer completes.</item>
            <item>A thread releases the event handling lock through <see cref="M:MonoLibUsb.MonoUsbApi.UnlockEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_unlock_events</see>.</item>
            </list>
            </para>
            <para>Condition 1 is obvious. Condition 2 unblocks your thread after the callback for the transfer has completed. Condition 3 is important because it means that the thread that was previously handling events is no longer doing so, so if any events are to complete, another thread needs to step up and start event handling.</para>
            <para>This function releases the event waiters lock before putting your thread to sleep, and reacquires the lock as it is being woken up.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="timeval">Maximum timeout for this blocking function.</param>
            <returns>
            <list type="bullet">
            <item>0 after a transfer completes or another thread stops event handling.</item>
            <item>1 if the timeout expired.</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.HandleEventsTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">
            <summary>
            Handle any pending events. 
            </summary>
            <remarks>
            <para>libusb determines "pending events" by checking if any timeouts have expired and by checking the set of file descriptors for activity.</para>
            <para>If a non-zero timeval is passed and no events are currently pending, this function will block waiting for events to handle up until the specified timeout. If an event arrives or a signal is raised, this function will return early.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="tv">The maximum time to block waiting for events, or zero for non-blocking mode</param>
            <returns>0 on success, or a <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.HandleEvents(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Handle any pending events in blocking mode with a sensible timeout.
            </summary>
            <remarks>
            <para>This timeout is currently hardcoded at 2 seconds but we may change this if we decide other values are more sensible. For finer control over whether this function is blocking or non-blocking, or the maximum timeout, use <see cref="M:MonoLibUsb.MonoUsbApi.HandleEventsTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_handle_events_timeout</see> instead.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <returns>0 on success, or a <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.HandleEventsLocked(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">
            <summary>
            Handle any pending events by polling file descriptors, without checking if any other threads are already doing so. 
            </summary>
            <remarks>
            <para>Must be called with the event lock held, see <see cref="M:MonoLibUsb.MonoUsbApi.LockEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_lock_events</see>.</para>
            <para>This function is designed to be called under the situation where you have taken the event lock and are calling poll()/select() directly on libusb's file descriptors (as opposed to using <see cref="M:MonoLibUsb.MonoUsbApi.HandleEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_handle_events</see> or similar). You detect events on libusb's descriptors, so you then call this function with a zero timeout value (while still holding the event lock).</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="tv">The maximum time to block waiting for events, or zero for non-blocking mode</param>
            <returns>0 on success, or a <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.PollfdsHandleTimeouts(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Determines whether your application must apply special timing considerations when monitoring libusb's file descriptors. 
            </summary>
            <remarks>
            <para>This function is only useful for applications which retrieve and poll libusb's file descriptors in their own main loop (The more advanced option).</para>
            <para>Ordinarily, libusb's event handler needs to be called into at specific moments in time (in addition to times when there is activity on the file descriptor set). The usual approach is to use <see cref="M:MonoLibUsb.MonoUsbApi.GetNextTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_get_next_timeout</see> to learn about when the next timeout occurs, and to adjust your poll()/select() timeout accordingly so that you can make a call into the library at that time.</para>
            <para>Some platforms supported by libusb do not come with this baggage - any events relevant to timing will be represented by activity on the file descriptor set, and <see cref="M:MonoLibUsb.MonoUsbApi.GetNextTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_get_next_timeout</see> will always return 0. This function allows you to detect whether you are running on such a platform.</para>
            <para>Since v1.0.5.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <returns>0 if you must call into libusb at times determined by <see cref="M:MonoLibUsb.MonoUsbApi.GetNextTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_get_next_timeout</see>, or 1 if all timeout events are handled internally or through regular activity on the file descriptors.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetNextTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">
            <summary>
            Determine the next internal timeout that libusb needs to handle. 
            </summary>
            <remarks>
            <para>You only need to use this function if you are calling poll() or select() or similar on libusb's file descriptors yourself - you do not need to use it if you are calling <see cref="M:MonoLibUsb.MonoUsbApi.HandleEvents(MonoLibUsb.MonoUsbSessionHandle)">libusb_handle_events</see> or a variant directly.</para>
            <para>You should call this function in your main loop in order to determine how long to wait for select() or poll() to return results. libusb needs to be called into at this timeout, so you should use it as an upper bound on your select() or poll() call.</para>
            <para>When the timeout has expired, call into <see cref="M:MonoLibUsb.MonoUsbApi.HandleEventsTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_handle_events_timeout</see> (perhaps in non-blocking mode) so that libusb can handle the timeout.</para>
            <para>This function may return 1 (success) and an all-zero timeval. If this is the case, it indicates that libusb has a timeout that has already expired so you should call <see cref="M:MonoLibUsb.MonoUsbApi.HandleEventsTimeout(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.UnixNativeTimeval@)">libusb_handle_events_timeout</see> or similar immediately. A return code of 0 indicates that there are no pending timeouts.</para>
            <para>On some platforms, this function will always returns 0 (no pending timeouts). See Notes on time-based events.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="tv">The maximum time to block waiting for events, or zero for non-blocking mode</param>
            <returns>0 if there are no pending timeouts, 1 if a timeout was returned, or <see cref="F:MonoLibUsb.MonoUsbError.ErrorOther"/> on failure.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.SetPollfdNotifiers(MonoLibUsb.MonoUsbSessionHandle,MonoLibUsb.PollfdAddedDelegate,MonoLibUsb.PollfdRemovedDelegate,System.IntPtr)">
            <summary>
            Register notification functions for file descriptor additions/removals. 
            </summary>
            <remarks>
            <para>To remove notifiers, pass NULL values for the function pointers.</para>
            <para>Note that file descriptors may have been added even before you register these notifiers (e.g. when a new <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> is created).</para>
            <para>Additionally, note that the removal notifier may be called during <see cref="M:MonoLibUsb.MonoUsbApi.Exit(System.IntPtr)"/> (e.g. when it is closing file descriptors that were opened and added to the poll set when a new <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> was created). If you don't want this, remove the notifiers immediately before calling <see cref="M:System.Runtime.InteropServices.SafeHandle.Close">MonoUsbSessionHandle.Close()</see>.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <param name="addedDelegate">Function delegate for addition notifications.</param>
            <param name="removedDelegate">Function delegate for removal notifications.</param>
            <param name="pUserData">User data to be passed back to callbacks (useful for passing sessionHandle information).</param>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.GetPollfds(MonoLibUsb.MonoUsbSessionHandle)">
            <summary>
            Retrieve a list of file descriptors that should be polled by your main loop as libusb event sources. 
            </summary>
            <remarks>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="poll"/></note>
            </remarks>
            <param name="sessionHandle">A valid <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/>.</param>
            <returns>A list of PollfdItem structures, or null on error.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.ControlTransfer(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.Byte,System.Int16,System.Int16,System.IntPtr,System.Int16,System.Int32)">
            <summary>
            Perform a USB control transfer.
            </summary>
            <remarks>
            <para>The direction of the transfer is inferred from the bmRequestType field of the setup packet.</para>
            <para>The wValue, wIndex and wLength fields values should be given in host-endian byte order.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="syncio"/></note>
            </remarks>
            <param name="deviceHandle">A handle for the device to communicate with.</param>
            <param name="requestType">The request type field for the setup packet.</param>
            <param name="request">The request field for the setup packet.</param>
            <param name="value">The value field for the setup packet</param>
            <param name="index">The index field for the setup packet.</param>
            <param name="pData">A suitably-sized data buffer for either input or output (depending on direction bits within bmRequestType).</param>
            <param name="dataLength">The length field for the setup packet. The data buffer should be at least this size.</param>
            <param name="timeout">timeout (in milliseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</param>
            <returns>
            <list type="bullet">
            <item>on success, the number of bytes actually transferred</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorTimeout"/> if the transfer timed out</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorPipe"/> if the control request was not supported by the device.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failures</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.ControlTransferAsync(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.Byte,System.Int16,System.Int16,System.IntPtr,System.Int16,System.Int32)">
            <summary>
            Perform a USB control transfer for multi-threaded applications using the <see cref="T:MonoLibUsb.MonoUsbEventHandler"/> class.
            </summary>
            <remarks>
            <para>The direction of the transfer is inferred from the bmRequestType field of the setup packet.</para>
            <para>The wValue, wIndex and wLength fields values should be given in host-endian byte order.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="syncio"/></note>
            </remarks>
            <param name="deviceHandle">A handle for the device to communicate with.</param>
            <param name="requestType">The request type field for the setup packet.</param>
            <param name="request">The request field for the setup packet.</param>
            <param name="value">The value field for the setup packet</param>
            <param name="index">The index field for the setup packet.</param>
            <param name="pData">A suitably-sized data buffer for either input or output (depending on direction bits within bmRequestType).</param>
            <param name="dataLength">The length field for the setup packet. The data buffer should be at least this size.</param>
            <param name="timeout">timeout (in milliseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</param>
            <returns>
            <list type="bullet">
            <item>on success, the number of bytes actually transferred</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorTimeout"/> if the transfer timed out</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorPipe"/> if the control request was not supported by the device.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failures</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.ControlTransfer(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.Byte,System.Int16,System.Int16,System.Object,System.Int16,System.Int32)">
            <summary>
            Perform a USB control transfer.
            </summary>
            <remarks>
            <para>The direction of the transfer is inferred from the bmRequestType field of the setup packet.</para>
            <para>The wValue, wIndex and wLength fields values should be given in host-endian byte order.</para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="syncio"/></note>
            </remarks>
            <param name="deviceHandle">A handle for the device to communicate with.</param>
            <param name="requestType">The request type field for the setup packet.</param>
            <param name="request">The request field for the setup packet.</param>
            <param name="value">The value field for the setup packet</param>
            <param name="index">The index field for the setup packet.</param>
            <param name="data">
            <para>A suitably-sized data buffer for either input or output (depending on direction bits within bmRequestType).</para>
            This value can be:
            <list type="bullet">
            <item>An <see cref="T:System.Array"/> of bytes or other <a href="http://msdn.microsoft.com/en-us/library/75dwhxf7.aspx">blittable</a> types.</item>
            <item>An already allocated, pinned <see cref="T:System.Runtime.InteropServices.GCHandle"/>. In this case <see cref="M:System.Runtime.InteropServices.GCHandle.AddrOfPinnedObject"/> is used for the buffer address.</item>
            <item>An <see cref="T:System.IntPtr"/>.</item>
            </list>
            </param>
            <param name="dataLength">The length field for the setup packet. The data buffer should be at least this size.</param>
            <param name="timeout">timeout (in milliseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</param>
            <returns>
            <list type="bullet">
            <item>on success, the number of bytes actually transferred</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorTimeout"/> if the transfer timed out</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorPipe"/> if the control request was not supported by the device.</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failures</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.BulkTransfer(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Int32@,System.Int32)">
            <summary>
            Perform a USB bulk transfer. 
            </summary>
            <remarks>
            <para>The direction of the transfer is inferred from the direction bits of the endpoint address.</para>
            <para>
            For bulk reads, the length field indicates the maximum length of data you are expecting to receive.
            If less data arrives than expected, this function will return that data, so be sure to check the 
            transferred output parameter.
            </para>
            <para>
            You should also check the transferred parameter for bulk writes. Not all of the data may have been 
            written. Also check transferred when dealing with a timeout error code. libusb may have to split 
            your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the 
            timeout may expire after the first few chunks have completed. libusb is careful not to lose any 
            data that may have been transferred; do not assume that timeout conditions indicate a complete lack 
            of I/O.
            </para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="syncio"/></note>
            </remarks>
            <param name="deviceHandle">A handle for the device to communicate with.</param>
            <param name="endpoint">The address of a valid endpoint to communicate with.</param>
            <param name="pData">
            A suitably-sized data buffer for either input or output (depending on endpoint).</param>
            <param name="length">For bulk writes, the number of bytes from data to be sent. for bulk reads, the maximum number of bytes to receive into the data buffer.</param>
            <param name="actualLength">Output location for the number of bytes actually transferred.</param>
            <param name="timeout">Timeout (in milliseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</param>
            <returns>
            <list type="bullet">
            <item>0 on success (and populates <paramref name="actualLength"/>)</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorTimeout"/> if the transfer timed out</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorPipe"/> if the endpoint halted</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorOverflow"/>if the device offered more data, see <a href="http://libusb.sourceforge.net/api-1.0/packetoverflow.html">Packets and overflows</a></item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failures</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.BulkTransfer(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.Object,System.Int32,System.Int32@,System.Int32)">
            <summary>
            Perform a USB bulk transfer. 
            </summary>
            <remarks>
            <para>The direction of the transfer is inferred from the direction bits of the endpoint address.</para>
            <para>
            For bulk reads, the length field indicates the maximum length of data you are expecting to receive.
            If less data arrives than expected, this function will return that data, so be sure to check the 
            transferred output parameter.
            </para>
            <para>
            You should also check the transferred parameter for bulk writes. Not all of the data may have been 
            written. Also check transferred when dealing with a timeout error code. libusb may have to split 
            your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the 
            timeout may expire after the first few chunks have completed. libusb is careful not to lose any 
            data that may have been transferred; do not assume that timeout conditions indicate a complete lack 
            of I/O.
            </para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="syncio"/></note>
            </remarks>
            <param name="deviceHandle">A handle for the device to communicate with.</param>
            <param name="endpoint">The address of a valid endpoint to communicate with.</param>
            <param name="data">
            <para>A suitably-sized data buffer for either input or output (depending on endpoint).</para>
            This value can be:
            <list type="bullet">
            <item>An <see cref="T:System.Array"/> of bytes or other <a href="http://msdn.microsoft.com/en-us/library/75dwhxf7.aspx">blittable</a> types.</item>
            <item>An already allocated, pinned <see cref="T:System.Runtime.InteropServices.GCHandle"/>. In this case <see cref="M:System.Runtime.InteropServices.GCHandle.AddrOfPinnedObject"/> is used for the buffer address.</item>
            <item>An <see cref="T:System.IntPtr"/>.</item>
            </list>
            </param>
            <param name="length">For bulk writes, the number of bytes from data to be sent. for bulk reads, the maximum number of bytes to receive into the data buffer.</param>
            <param name="actualLength">Output location for the number of bytes actually transferred.</param>
            <param name="timeout">Timeout (in milliseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</param>
            <returns>
            <list type="bullet">
            <item>0 on success (and populates <paramref name="actualLength"/>)</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorTimeout"/> if the transfer timed out</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorPipe"/> if the endpoint halted</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorOverflow"/>if the device offered more data, see <a href="http://libusb.sourceforge.net/api-1.0/packetoverflow.html">Packets and overflows</a></item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failures</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.InterruptTransfer(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.IntPtr,System.Int32,System.Int32@,System.Int32)">
            <summary>
            Perform a USB interrupt transfer. 
            </summary>
            <remarks>
            <para>
            The direction of the transfer is inferred from the direction bits of the endpoint address.
            </para><para>
            For interrupt reads, the length field indicates the maximum length of data you are expecting to receive.
            If less data arrives than expected, this function will return that data, so be sure to check the 
            transferred output parameter.
            </para><para>
            You should also check the transferred parameter for interrupt writes. Not all of the data may have been 
            written. Also check transferred when dealing with a timeout error code. libusb may have to split 
            your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the 
            timeout may expire after the first few chunks have completed. libusb is careful not to lose any 
            data that may have been transferred; do not assume that timeout conditions indicate a complete lack 
            of I/O.
            </para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="syncio"/></note>
            </remarks>
            <param name="deviceHandle">A handle for the device to communicate with.</param>
            <param name="endpoint">The address of a valid endpoint to communicate with.</param>
            <param name="pData">A suitably-sized data buffer for either input or output (depending on endpoint).</param>
            <param name="length">For interrupt writes, the number of bytes from data to be sent. for interrupt reads, the maximum number of bytes to receive into the data buffer.</param>
            <param name="actualLength">Output location for the number of bytes actually transferred.</param>
            <param name="timeout">Timeout (in milliseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</param>
            <returns>
            <list type="bullet">
            <item>0 on success (and populates <paramref name="actualLength"/>)</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorTimeout"/> if the transfer timed out</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorPipe"/> if the endpoint halted</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorOverflow"/>if the device offered more data, see <a href="http://libusb.sourceforge.net/api-1.0/packetoverflow.html">Packets and overflows</a></item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failures</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.InterruptTransfer(MonoLibUsb.MonoUsbDeviceHandle,System.Byte,System.Object,System.Int32,System.Int32@,System.Int32)">
            <summary>
            Perform a USB interrupt transfer. 
            </summary>
            <remarks>
            <para>
            The direction of the transfer is inferred from the direction bits of the endpoint address.
            </para><para>
            For interrupt reads, the length field indicates the maximum length of data you are expecting to receive.
            If less data arrives than expected, this function will return that data, so be sure to check the 
            transferred output parameter.
            </para><para>
            You should also check the transferred parameter for interrupt writes. Not all of the data may have been 
            written. Also check transferred when dealing with a timeout error code. libusb may have to split 
            your transfer into a number of chunks to satisfy underlying O/S requirements, meaning that the 
            timeout may expire after the first few chunks have completed. libusb is careful not to lose any 
            data that may have been transferred; do not assume that timeout conditions indicate a complete lack 
            of I/O.
            </para>
            <note type="tip" title="Libusb-1.0 API:"><seelibusb10 group="syncio"/></note>
            </remarks>
            <param name="deviceHandle">A handle for the device to communicate with.</param>
            <param name="endpoint">The address of a valid endpoint to communicate with.</param>
            <param name="data">
            <para>A suitably-sized data buffer for either input or output (depending on endpoint).</para>
            This value can be:
            <list type="bullet">
            <item>An <see cref="T:System.Array"/> of bytes or other <a href="http://msdn.microsoft.com/en-us/library/75dwhxf7.aspx">blittable</a> types.</item>
            <item>An already allocated, pinned <see cref="T:System.Runtime.InteropServices.GCHandle"/>. In this case <see cref="M:System.Runtime.InteropServices.GCHandle.AddrOfPinnedObject"/> is used for the buffer address.</item>
            <item>An <see cref="T:System.IntPtr"/>.</item>
            </list>
            </param>
            <param name="length">For interrupt writes, the number of bytes from data to be sent. for interrupt reads, the maximum number of bytes to receive into the data buffer.</param>
            <param name="actualLength">Output location for the number of bytes actually transferred.</param>
            <param name="timeout">Timeout (in milliseconds) that this function should wait before giving up due to no response being received. For an unlimited timeout, use value 0.</param>
            <returns>
            <list type="bullet">
            <item>0 on success (and populates <paramref name="actualLength"/>)</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorTimeout"/> if the transfer timed out</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorPipe"/> if the endpoint halted</item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorOverflow"/>if the device offered more data, see <a href="http://libusb.sourceforge.net/api-1.0/packetoverflow.html">Packets and overflows</a></item>
            <item><see cref="F:MonoLibUsb.MonoUsbError.ErrorNoDevice"/> if the device has been disconnected</item>
            <item>another <see cref="T:MonoLibUsb.MonoUsbError"/> code on other failures</item>
            </list>
            </returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.StrError(MonoLibUsb.MonoUsbError)">
            <summary>
            Get a string describing a <see cref="T:MonoLibUsb.MonoUsbError"/>.
            </summary>
            <param name="errcode">The <see cref="T:MonoLibUsb.MonoUsbError"/> code to retrieve a description for.</param>
            <returns>A string describing the <see cref="T:MonoLibUsb.MonoUsbError"/> code.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.MonoLibUsbErrorFromTransferStatus(MonoLibUsb.Transfer.MonoUsbTansferStatus)">
            <summary>
            Converts a <see cref="T:MonoLibUsb.Transfer.MonoUsbTansferStatus"/> enum to a <see cref="T:MonoLibUsb.MonoUsbError"/> enum.
            </summary>
            <param name="status">the <see cref="T:MonoLibUsb.Transfer.MonoUsbTansferStatus"/> to convert.</param>
            <returns>A <see cref="T:MonoLibUsb.MonoUsbError"/> that represents <paramref name="status"/>.</returns>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.InitAndStart">
            <summary>
            Calls <see cref="M:MonoLibUsb.MonoUsbEventHandler.Init"/> and <see cref="M:MonoLibUsb.MonoUsbEventHandler.Start"/> if <see cref="P:MonoLibUsb.MonoUsbEventHandler.IsStopped"/> = true.
            </summary>
        </member>
        <member name="M:MonoLibUsb.MonoUsbApi.StopAndExit">
            <summary>
            Calls <see cref="M:MonoLibUsb.MonoUsbEventHandler.Stop(System.Boolean)"/> and <see cref="M:MonoLibUsb.MonoUsbEventHandler.Exit"/>.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbCtrlFlags">
            <summary>For Convienience Endpoint direction, recipient of the request, and request type on one enumeration.</summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.Direction_In">
            <summary>
            In Direction
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.Direction_Out">
            <summary>
            Out Direction
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.Recipient_Device">
            <summary>
            Device is recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.Recipient_Endpoint">
            <summary>
            Endpoint is recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.Recipient_Interface">
            <summary>
            Interface is recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.Recipient_Other">
            <summary>
            Other is recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.RequestType_Class">
            <summary>
            Class specific request.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.RequestType_Reserved">
            <summary>
            RESERVED.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.RequestType_Standard">
            <summary>
            Standard request.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbCtrlFlags.RequestType_Vendor">
            <summary>
            Vendor specific request.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifierMode">
            <summary>
             Modes the linux device notifier can use to detect notification events.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifierMode.None">
            <summary>
            The device notifier is unavailable on this platform.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifierMode.PollDeviceList">
            <summary>
            The device notifier is polling the device list every 750ms to detect usb add and removal events.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.DeviceNotify.Linux.LinuxDeviceNotifierMode.MonitorDevDirectory">
            <summary>
            The device notifier is using a <see cref="T:System.IO.FileSystemWatcher"/> to monitor the "/dev" directory for file add and delete.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbSetupPacket">
            <summary> Transfers data to the main control endpoint (Endpoint 0).
            </summary> 
            <remarks> All USB devices respond to requests from the host on the device’s Default Control Pipe. These requests are made using control transfers. The request and the request’s parameters are sent to the device in the Setup packet. The host is responsible for establishing the values passed in the fields. Every Setup packet has eight bytes.
            </remarks> 
        </member>
        <member name="F:LibUsbDotNet.Main.UsbSetupPacket.RequestType">
            <summary>
            This bitmapped field identifies the characteristics of the specific request. In particular, this field identifies the direction of data transfer in the second phase of the control transfer. The state of the Direction bit is ignored if the wLength field is zero, signifying there is no Data stage.
            The USB Specification defines a series of standard requests that all devices must support. In addition, a device class may define additional requests. A device vendor may also define requests supported by the device.
            Requests may be directed to the device, an interface on the device, or a specific endpoint on a device. This field also specifies the intended recipient of the request. When an interface or endpoint is specified, the wIndex field identifies the interface or endpoint.
            </summary>
            <remarks>
            <ul>Characteristics of request:
            <li>D7: Data transfer direction</li>
            <li>0 = Host-to-device</li>
            <li>1 = Device-to-host</li>
            <li>D6...5: Type</li>
            <li>0 = Standard</li>
            <li>1 = Class</li>
            <li>2 = Vendor</li>
            <li>3 = Reserved</li>
            <li>D4...0: Recipient</li>
            <li>0 = Device</li>
            <li>1 = Interface</li>
            <li>2 = Endpoint</li>
            <li>3 = Other</li>
            <li>4...31 = Reserved</li>
            </ul>
            </remarks>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbSetupPacket.Request">
            <summary>
            This field specifies the particular request. The Type bits in the bmRequestType field modify the meaning of this field. This specification defines values for the bRequest field only when the bits are reset to zero, indicating a standard request.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbSetupPacket.Value">
            <summary>
            The contents of this field vary according to the request. It is used to pass a parameter to the device, specific to the request.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbSetupPacket.Index">
            <summary>
            The contents of this field vary according to the request. It is used to pass a parameter to the device, specific to the request.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbSetupPacket.Length">
            <summary>
            This field specifies the length of the data transferred during the second phase of the control transfer. The direction of data transfer (host-to-device or device-to-host) is indicated by the Direction bit of the <see cref="F:LibUsbDotNet.Main.UsbSetupPacket.RequestType"/> field. If this field is zero, there is no data transfer phase. On an input request, a device must never return more data than is indicated by the wLength value; it may return less. On an output request, wLength will always indicate the exact amount of data to be sent by the host. Device behavior is undefined if the host should send more data than is specified in wLength.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbSetupPacket.#ctor(System.Byte,System.Byte,System.Int16,System.Int16,System.Int16)">
            <summary>
            Creates a new instance of a <see cref="T:LibUsbDotNet.Main.UsbSetupPacket"/> and initializes all the fields with the following parameters.
            </summary>
            <param name="requestType">See <see cref="F:LibUsbDotNet.Main.UsbSetupPacket.RequestType"/>.</param>
            <param name="request">See <see cref="F:LibUsbDotNet.Main.UsbSetupPacket.Request"/>.</param>
            <param name="value">See <see cref="F:LibUsbDotNet.Main.UsbSetupPacket.Value"/>.</param>
            <param name="index">See <see cref="F:LibUsbDotNet.Main.UsbSetupPacket.Index"/>.</param>
            <param name="length">See <see cref="F:LibUsbDotNet.Main.UsbSetupPacket.Length"/>.</param>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.Internal.MonoUsbTransferContext.Fill(System.IntPtr,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills the transfer with the data to <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/>.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset on the buffer where the transfer should read/write.</param>
            <param name="count">The number of bytes to transfer.</param>
            <param name="timeout">Time (milliseconds) to wait before the transfer times out.</param>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.Internal.MonoUsbTransferContext.Fill(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Fills the transfer with the data to <see cref="M:LibUsbDotNet.Main.UsbTransfer.Submit"/> an isochronous transfer.
            </summary>
            <param name="buffer">The buffer.</param>
            <param name="offset">The offset on the buffer where the transfer should read/write.</param>
            <param name="count">The number of bytes to transfer.</param>
            <param name="timeout">Time (milliseconds) to wait before the transfer times out.</param>
            <param name="isoPacketSize">Size of each isochronous packet.</param>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.Internal.MonoUsbTransferContext.Submit">
            <summary>
            Submits the transfer.
            </summary>
            <remarks>
            This functions submits the USB transfer and return immediately.
            </remarks>
            <returns>
            <see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if the submit succeeds, 
            otherwise one of the other <see cref="T:LibUsbDotNet.Main.ErrorCode"/> codes.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.LudnMonoLibUsb.Internal.MonoUsbTransferContext.Wait(System.Int32@,System.Boolean)">
            <summary>
            Wait for the transfer to complete, timeout, or get cancelled.
            </summary>
            <param name="transferredCount">The number of bytes transferred on <see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/>.</param>
            <param name="cancel">Not used for libusb-1.0. Transfers are always cancelled on timeout or error.</param>
            <returns><see cref="F:LibUsbDotNet.Main.ErrorCode.Success"/> if the transfer completes successfully, otherwise one of the other <see cref="T:LibUsbDotNet.Main.ErrorCode"/> codes.</returns>
        </member>
        <member name="T:LibUsbDotNet.Main.SPDRP">
            <summary>
            Device registry property codes
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.DeviceDesc">
            <summary>
            Requests a string describing the device, such as "Microsoft PS/2 Port Mouse", typically defined by the manufacturer. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.HardwareId">
            <summary>
            Requests the hardware IDs provided by the device that identify the device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.CompatibleIds">
            <summary>
            Requests the compatible IDs reported by the device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.Class">
            <summary>
            Requests the name of the device's setup class, in text format. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.ClassGuid">
            <summary>
            Requests the GUID for the device's setup class.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.Driver">
            <summary>
            Requests the name of the driver-specific registry key.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.Mfg">
            <summary>
            Requests a string identifying the manufacturer of the device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.FriendlyName">
            <summary>
            Requests a string that can be used to distinguish between two similar devices, typically defined by the class installer.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.LocationInformation">
            <summary>
            Requests information about the device's location on the bus; the interpretation of this information is bus-specific. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.PhysicalDeviceObjectName">
            <summary>
            Requests the name of the PDO for this device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.UiNumber">
            <summary>
            Requests a number associated with the device that can be displayed in the user interface.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.BusTypeGuid">
            <summary>
            Requests the GUID for the bus that the device is connected to.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.LegacyBusType">
            <summary>
            Requests the bus type, such as PCIBus or PCMCIABus.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.BusNumber">
            <summary>
            Requests the legacy bus number of the bus the device is connected to. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.EnumeratorName">
            <summary>
            Requests the name of the enumerator for the device, such as "USB".
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.Address">
            <summary>
            Requests the address of the device on the bus. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.RemovalPolicy">
            <summary>
            (Windows XP and later.) Requests the device's current removal policy. The operating system uses this value as a hint to determine how the device is normally removed.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.InstallState">
            <summary>
            Windows XP and later.) Requests the device's installation state.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.SPDRP.LocationPaths">
            <summary>
            Device Location Paths (R)
            </summary>
        </member>
        <member name="T:MonoLibUsb.Profile.MonoUsbProfileListHandle">
            <summary>
            Used to iterate through the <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> collection contained in the <see cref="T:MonoLibUsb.Profile.MonoUsbProfileListHandle"/>.
            </summary>
            <remarks>
            <para>Wraps a device list handle into a <see cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject"/></para>
            </remarks>
            <seealso cref="T:MonoLibUsb.Profile.MonoUsbProfileList"/>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileListHandle.GetEnumerator">
            <summary>
            Gets a forward-only device list enumerator.
            </summary>
            <returns>A profile handle enumerator used iterating through the <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> classes.</returns>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileListHandle.ReleaseHandle">
            <summary>
            When overridden in a derived class, executes the code required to free the handle.
            </summary>
            <returns>
            true if the handle is released successfully; otherwise, in the event of a catastrophic failure, false. In this case, it generates a ReleaseHandleFailed Managed Debugging Assistant.
            </returns>
        </member>
        <member name="T:MonoLibUsb.Transfer.MonoUsbIsoPacket">
            <summary>
            Wraps an iso packet structure
            </summary>
        </member>
        <member name="M:MonoLibUsb.Transfer.MonoUsbIsoPacket.#ctor(System.IntPtr)">
            <summary>
            Creates a structure that wraps an iso packet.
            </summary>
            <param name="isoPacketPtr">The pointer to the iso packet to wrap.</param>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbIsoPacket.PtrIsoPacket">
            <summary>
            Returns the location in memory of this iso packet.
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbIsoPacket.ActualLength">
            <summary>
            Amount of data that was actually transferred. 
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbIsoPacket.Length">
            <summary>
            Length of data to request in this packet. 
            </summary>
        </member>
        <member name="P:MonoLibUsb.Transfer.MonoUsbIsoPacket.Status">
            <summary>
            Status code for this packet. 
            </summary>
        </member>
        <member name="T:MonoLibUsb.Profile.PollfdItem">
            <summary>
            File descriptor for polling. <a href="http://libusb.sourceforge.net/api-1.0/structlibusb__pollfd.html#_details">More..</a>
            </summary>
        </member>
        <member name="F:MonoLibUsb.Profile.PollfdItem.fd">
            <summary>
            Numeric file descriptor.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Profile.PollfdItem.events">
            <summary>
            Event flags to poll for from poll.h. 
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifyEventArgs">
            <summary>
            Describes the device notify event
            </summary> 
        </member>
        <member name="T:LibUsbDotNet.Main.EndpointType">
            <summary> All possible USB endpoint types.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.EndpointType.Control">
            <summary>
            Control endpoint type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.EndpointType.Isochronous">
            <summary>
            Isochronous endpoint type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.EndpointType.Bulk">
            <summary>
            Bulk endpoint type.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.EndpointType.Interrupt">
            <summary>
            Interrupt endpoint type.
            </summary>
        </member>
        <member name="T:MonoLibUsb.MonoUsbError">
            <summary>
            Error codes.
            Most libusb functions return 0 on success or one of these codes on failure. 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.Success">
            <summary>
            Success (no error) 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorIO">
            <summary>
            Input/output error 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorInvalidParam">
            <summary>
            Invalid parameter 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorAccess">
            <summary>
            Access denied (insufficient permissions) 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorNoDevice">
            <summary>
            No such device (it may have been disconnected) 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorNotFound">
            <summary>
            Entity not found 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorBusy">
            <summary>
            Resource busy 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorTimeout">
            <summary>
            Operation timed out 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorOverflow">
            <summary>
            Overflow 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorPipe">
            <summary>
            Pipe error 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorInterrupted">
            <summary>
            System call interrupted (perhaps due to signal) 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorNoMem">
            <summary>
            Insufficient memory 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorNotSupported">
            <summary>
            Operation not supported or unimplemented on this platform 
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorIOCancelled">
            <summary>
            Cancel IO failed.
            </summary>
        </member>
        <member name="F:MonoLibUsb.MonoUsbError.ErrorOther">
            <summary>
            Other error 
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.Helper">
            <summary>
            General utilities class used by LudnLite and exposed publicly for your convience.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.Helper.BytesToObject(System.Byte[],System.Int32,System.Int32,System.Object)">
            <summary>
            Copies bytes to a blittable object.
            </summary>
            <param name="sourceBytes">bytes to copy</param>
            <param name="iStartIndex">Start index</param>
            <param name="iLength">number of bytes to copy</param>
            <param name="destObject">blittable destination object</param>
        </member>
        <member name="M:LibUsbDotNet.Main.Helper.GetEnumData(System.Type)">
            <summary>
            Returns a dictionary object of enumeration names and values.
            </summary>
            <param name="type">They <see cref="T:System.Type"/> of enumeration.</param>
            <returns>A <see cref="T:System.Collections.Generic.Dictionary`2"/> enumeration of names and values.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.Helper.HostEndianToLE16(System.Int16)">
            <summary>
            Swaps low and high bytes on big endian systems.  Has no effect on little endian systems.
            </summary>
            <param name="swapValue">The value to convert.</param>
            <returns>a swapped value an big endian system, the same value on little endian systems</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.Helper.ShowAsHex(System.Object)">
            <summary>
            Converts standard values to decorated hex string values.
            </summary>
            <param name="standardValue">The value to convert.</param>
            <returns>A string representing <paramref name="standardValue"/> in hex display format.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.Helper.ToString(System.String,System.String[],System.String,System.Object[],System.String)">
            <summary>
            Builds a delimited string of names and values.
            </summary>
            <param name="sep0">Inserted and the begining of the entity.</param>
            <param name="names">The list of names for the object values.</param>
            <param name="sep1">Inserted between the name and value.</param>
            <param name="values">The values for the names.</param>
            <param name="sep2">Inserted and the end of the entity.</param>
            <returns>The formatted string.</returns>
        </member>
        <member name="M:LibUsbDotNet.Main.Helper.HexString(System.Byte[],System.String,System.String)">
            <summary>
            Builds a formatted hexidecimal string from an array of bytes. 
            </summary>
            <param name="data">the byte array</param>
            <param name="prefix">string to place before each byte</param>
            <param name="suffix">string to place after each byte</param>
            <returns>a formatted hex string</returns>
        </member>
        <member name="P:LibUsbDotNet.Main.Helper.OSVersion">
            <summary>
            Gets the  <see cref="T:System.OperatingSystem"/> class.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.Helper.IsLinux">
            <summary>
            True if running on a unix-like operating system.
            False if using the Libusb-1.0 windows backend driver.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.PinnedHandle">
            <summary>
            Used for allocating a <see cref="T:System.Runtime.InteropServices.GCHandle"/> to access the underlying pointer of an object.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.PinnedHandle.#ctor(System.Object)">
            <summary>
            Creates a pinned object.
            </summary>
            <param name="objectToPin">
            The object can be any blittable class, or array.  If a <see cref="T:System.Runtime.InteropServices.GCHandle"/> is passed it will be used "as-is" and no pinning will take place. 
            </param>
        </member>
        <member name="M:LibUsbDotNet.Main.PinnedHandle.Dispose">
            <summary>
            Frees and disposes the <see cref="T:System.Runtime.InteropServices.GCHandle"/> for this pinned object.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:LibUsbDotNet.Main.PinnedHandle.Finalize">
            <summary>
            Disposes the gchande for the object if ibe is allocated.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.Main.PinnedHandle.Handle">
            <summary>
            The raw pointer in memory of the pinned object.
            </summary>
        </member>
        <member name="T:MonoLibUsb.MonoUsbSessionHandle">
            <summary>
            Class representing a Libusb-1.0 session session handle.
            Session handled are wrapped in a <see cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject"/>. 
            </summary>
            <remarks>
            <para>The concept of individual Libusb-1.0 sessions allows for your program to use two libraries 
            (or dynamically load two modules) which both independently use libusb. This will prevent interference between the 
            individual libusb users - for example <see cref="M:MonoLibUsb.MonoUsbApi.SetDebug(MonoLibUsb.MonoUsbSessionHandle,System.Int32)"/> will not affect the other 
            user of the library, and <see cref="M:System.Runtime.InteropServices.SafeHandle.Close"/> will not destroy resources that the 
            other user is still using.</para>
            <para>Sessions are created when a new <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> instance is created and destroyed through <see cref="M:System.Runtime.InteropServices.SafeHandle.Close"/>.</para>
            <para>A <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> instance must be created before calling any other <a href="http://libusb.sourceforge.net/api-1.0/index.html">Libusb-1.0 API</a> function.</para>
            <para>Session handles are equivalent to a <a href="http://libusb.sourceforge.net/api-1.0/group__lib.html#ga4ec088aa7b79c4a9599e39bf36a72833">libusb_context</a>.</para>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.MonoUsbSessionHandle.#ctor">
            <summary>
            Creates and initialize a <a href="http://libusb.sourceforge.net/api-1.0/index.html">Libusb-1.0</a> USB session handle.
            </summary>
            <remarks>
            <para>A <see cref="T:MonoLibUsb.MonoUsbSessionHandle"/> instance must be created before calling any other <a href="http://libusb.sourceforge.net/api-1.0/index.html">Libusb-1.0 API</a> function.</para>
            </remarks>
        </member>
        <member name="M:MonoLibUsb.MonoUsbSessionHandle.ReleaseHandle">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MonoLibUsb.MonoUsbSessionHandle.LastErrorCode">
            <summary>
            If the session handle is <see cref="P:LibUsbDotNet.Main.SafeContextHandle.IsInvalid"/>, gets the <see cref="T:MonoLibUsb.MonoUsbError"/> status code indicating the reason.
            </summary>
        </member>
        <member name="P:MonoLibUsb.MonoUsbSessionHandle.LastErrorString">
            <summary>
            If the session handle is <see cref="P:LibUsbDotNet.Main.SafeContextHandle.IsInvalid"/>, gets a descriptive string for the <see cref="P:MonoLibUsb.MonoUsbSessionHandle.LastErrorCode"/>.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbRequestRecipient">
            <summary>Recipient of the request.</summary>
             <seealso cref="T:LibUsbDotNet.Main.UsbCtrlFlags"/>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestRecipient.RecipDevice">
            <summary>
            Device is recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestRecipient.RecipEndpoint">
            <summary>
            Endpoint is recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestRecipient.RecipInterface">
            <summary>
            Interface is recipient.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbRequestRecipient.RecipOther">
            <summary>
            Other is recipient.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Info.UsbEndpointInfo">
            <summary> Contains Endpoint information for the current <see cref="T:LibUsbDotNet.Info.UsbConfigInfo"/>.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.Info.UsbEndpointInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbEndpointInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbEndpointInfo"/>.
            </returns>
        </member>
        <member name="M:LibUsbDotNet.Info.UsbEndpointInfo.ToString(System.String,System.String,System.String)">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.Info.UsbEndpointInfo"/>.
            </summary>
            
            <param name="prefixSeperator">The field prefix string.</param>
            <param name="entitySperator">The field/value seperator string.</param>
            <param name="suffixSeperator">The value suffix string.</param>
            <returns>A formatted representation of the <see cref="T:LibUsbDotNet.Info.UsbEndpointInfo"/>.</returns>
        </member>
        <member name="P:LibUsbDotNet.Info.UsbEndpointInfo.Descriptor">
            <summary>
            Gets the <see cref="T:LibUsbDotNet.Descriptors.UsbEndpointDescriptor"/> information.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo">
            <summary> Describes the USB device that caused the notification.
            See the <see cref="T:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo"/> inteface for more information.
            </summary>  
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.SymbolicName">
            <summary>
            The symbolc name class for this device.  For more information, see <see cref="T:LibUsbDotNet.Main.UsbSymbolicName"/>.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.Name">
            <summary>
            Gets the full name of the USB device that caused the notification.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.ClassGuid">
            <summary>
            Gets the Class Guid of the USB device that caused the notification.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.IdVendor">
            <summary>
            Parses and returns the VID from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.IdProduct">
            <summary>
            Parses and returns the PID from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.SerialNumber">
            <summary>
            Parses and returns the serial number from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Transfer.MonoUsbTransferFlags">
            <summary>
            Transfer flags.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTransferFlags.None">
            <summary>
            No transfer flags.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTransferFlags.TransferShortNotOk">
            <summary>
            Report short frames as errors
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTransferFlags.TransferFreeBuffer">
            <summary>
            Automatically free() transfer buffer during <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free">MonoUsbTransfer.Free()</see>.
            </summary>
        </member>
        <member name="F:MonoLibUsb.Transfer.MonoUsbTransferFlags.TransferFreeTransfer">
            <summary>
            Automatically call <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free">MonoUsbTransfer.Free()</see> after callback returns.
            </summary>
            <remakrks>
            <para>If this flag is set, it is illegal to call <see cref="M:MonoLibUsb.Transfer.MonoUsbTransfer.Free"/> from your transfer callback, as this will result in a double-free when this flag is acted upon.</para>
            </remakrks>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbKernelVersion">
            <summary>
             Contains version information for the LibUsb Sys driver.
            </summary>
             <remarks>
             This version is not related to LibUsbDotNet.  TO get the LibUsbDotNet version use .NET reflections.
             </remarks>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbKernelVersion.Major">
            <summary>
            LibUsb-Win32 Major version
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbKernelVersion.Minor">
            <summary>
            LibUsb-Win32 Minor version
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbKernelVersion.Micro">
            <summary>
            LibUsb-Win32 Micro version
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbKernelVersion.Nano">
            <summary>
            LibUsb-Win32 Nano version
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbKernelVersion.BcdLibUsbDotNetKernelMod">
            <summary>
            The LibUsbDotNet - LibUsb-Win32 binary mod code. if not running the LibUsbDotNet LibUsb-Win32 modified kernel driver, this value is 0.
            </summary>
        </member>
        <member name="M:LibUsbDotNet.Main.UsbKernelVersion.ToString">
            <summary>
            The full LibUsb-Win32 kernel driver version (libusb0.sys).
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> containing the full LibUsb-Win32 version.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.Main.UsbKernelVersion.IsEmpty">
            <summary>
            True if Major == 0 and Minor == 0 and Micro == 0 and Nano == 0.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.Main.DevicePropertyType">
            <summary> Standard Windows registry properties for USB devices and other hardware.
            </summary> 
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.DeviceDesc">
            <summary>
            Requests a string describing the device, such as "Microsoft PS/2 Port Mouse", typically defined by the manufacturer. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.HardwareId">
            <summary>
            Requests the hardware IDs provided by the device that identify the device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.CompatibleIds">
            <summary>
            Requests the compatible IDs reported by the device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.Class">
            <summary>
            Requests the name of the device's setup class, in text format. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.ClassGuid">
            <summary>
            Requests the GUID for the device's setup class.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.Driver">
            <summary>
            Requests the name of the driver-specific registry key.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.Mfg">
            <summary>
            Requests a string identifying the manufacturer of the device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.FriendlyName">
            <summary>
            Requests a string that can be used to distinguish between two similar devices, typically defined by the class installer.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.LocationInformation">
            <summary>
            Requests information about the device's location on the bus; the interpretation of this information is bus-specific. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.PhysicalDeviceObjectName">
            <summary>
            Requests the name of the PDO for this device.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.BusTypeGuid">
            <summary>
            Requests the GUID for the bus that the device is connected to.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.LegacyBusType">
            <summary>
            Requests the bus type, such as PCIBus or PCMCIABus.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.BusNumber">
            <summary>
            Requests the legacy bus number of the bus the device is connected to. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.EnumeratorName">
            <summary>
            Requests the name of the enumerator for the device, such as "USB".
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.Address">
            <summary>
            Requests the address of the device on the bus. 
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.UiNumber">
            <summary>
            Requests a number associated with the device that can be displayed in the user interface.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.InstallState">
            <summary>
            Windows XP and later.) Requests the device's installation state.
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.DevicePropertyType.RemovalPolicy">
            <summary>
            (Windows XP and later.) Requests the device's current removal policy. The operating system uses this value as a hint to determine how the device is normally removed.
            </summary>
        </member>
        <member name="T:MonoLibUsb.Profile.MonoUsbProfileHandleEnumerator">
            <summary>
            A forward-only enumerator for iterating a device lists.
            </summary>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileHandleEnumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileHandleEnumerator.MoveNext">
            <summary>
            Advances the enumerator to the next <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> element of the collection.
            </summary>
            <returns>
            true if the enumerator was successfully advanced to the next element; false if the enumerator has passed the end of the collection.
            </returns>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:MonoLibUsb.Profile.MonoUsbProfileHandleEnumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
            <exception cref="T:System.InvalidOperationException">The collection was modified after the enumerator was created. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfileHandleEnumerator.Current">
            <summary>
            Gets the element in the <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> collection at the current position of the enumerator.
            </summary>
            <returns>
            The current <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> element.
            </returns>
        </member>
        <member name="P:MonoLibUsb.Profile.MonoUsbProfileHandleEnumerator.System#Collections#IEnumerator#Current">
            <summary>
            Gets the current element in the <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> collection.
            </summary>
            <returns>
            The current <see cref="T:MonoLibUsb.Profile.MonoUsbProfileHandle"/> element.
            </returns>
            <exception cref="T:System.InvalidOperationException">The enumerator is positioned before the first element of the collection or after the last element.-or- The collection was modified after the enumerator was created.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="T:LibUsbDotNet.Main.UsbEndpointDirection">
            <summary>Endpoint direction.</summary>
             <seealso cref="T:LibUsbDotNet.Main.UsbCtrlFlags"/>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbEndpointDirection.EndpointIn">
            <summary>
            In Direction
            </summary>
        </member>
        <member name="F:LibUsbDotNet.Main.UsbEndpointDirection.EndpointOut">
            <summary>
            Out Direction
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifier">
            <summary>
            Notifies an application of a change to the hardware Configuration of a device or 
            the computer. See <see cref="T:LibUsbDotNet.DeviceNotify.IDeviceNotifier"/> or <see cref="M:LibUsbDotNet.DeviceNotify.DeviceNotifier.OpenDeviceNotifier"/> interface for more information
            </summary>
            <remarks>
            This is the windows implementation of the device notifier.
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifier.#ctor">
            <summary>
             Creates an instance of the <see cref="T:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifier"/> class.
             See the <see cref="T:LibUsbDotNet.DeviceNotify.IDeviceNotifier"/> interface or <see cref="M:LibUsbDotNet.DeviceNotify.DeviceNotifier.OpenDeviceNotifier"/> method for more information
            </summary>
            <remarks>
            To make your code platform-independent use the <see cref="M:LibUsbDotNet.DeviceNotify.DeviceNotifier.OpenDeviceNotifier"/> method for creating instances.
            </remarks>
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifier.Finalize">
            <summary>
            Releases the resources associated with this window. 
            </summary>
            
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifier.Enabled">
            <summary>
             Enables/Disables notification events.
            </summary>
        </member>
        <member name="E:LibUsbDotNet.DeviceNotify.WindowsDeviceNotifier.OnDeviceNotify">
            <summary>
            Main Notify event for all device notifications.
            </summary>
        </member>
        <member name="T:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo">
            <summary> Describes the USB device that caused the notification.
            see the <see cref="T:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo"/> inteface for more information.
            </summary> 
        </member>
        <member name="M:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo"/>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:LibUsbDotNet.DeviceNotify.Info.UsbDeviceNotifyInfo"/>.
            </returns>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.DeviceDescriptor">
            <summary>
             Gets the <see cref="T:LibUsbDotNet.Descriptors.UsbDeviceDescriptor"/> for the device that caused the event.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.BusNumber">
            <summary>
            Gets the bus number the device is connected to.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.DeviceAddress">
            <summary>
            Get the device instance address.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.SymbolicName">
            <summary>
            Not supported.  Always returns null.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.Name">
            <summary>
            Gets the name of the USB device file descriptor that caused the notification.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.ClassGuid">
            <summary>
            Not supported. Always returs Guid.Empty.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.IdVendor">
            <summary>
            Parses and returns the VID from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.IdProduct">
            <summary>
            Parses and returns the PID from the <see cref="P:LibUsbDotNet.DeviceNotify.Info.IUsbDeviceNotifyInfo.Name"/> property.
            </summary>
        </member>
        <member name="P:LibUsbDotNet.DeviceNotify.Linux.LinuxUsbDeviceNotifyInfo.SerialNumber">
            <summary>
            Not supported.  Always returns String.Empty.
            </summary>
        </member>
    </members>
</doc>
